<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>스트림스 게임 - 공유 랭킹(전체/월별)</title>
  <style>
    body { background:#fff; color:#000; font-family:system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, Malgun Gothic, Arial, sans-serif; text-align:center; margin:0; padding:0 0 60px; }
    .container { width: fit-content; margin: 0 auto; padding: 20px; }
    h1, h3, p, table, button, #jokerArea { margin-left:auto; margin-right:auto; width: fit-content; }
    p:not(:has(label)) { text-align:left; max-width:600px; margin-left:auto; margin-right:auto; }
    .tile-container { display:flex; flex-wrap:wrap; justify-content:center; margin:10px 0; width:250px; min-height:48px; border:1px dashed #eee; padding:5px; box-sizing:border-box; }
    #drawnTileArea { min-height:48px; display:flex; justify-content:center; align-items:center; margin:10px 0; width:250px; border:1px dashed #ccc; box-sizing:border-box; }
    .board { display:flex; justify-content:flex-start; margin:20px 0; width:880px; border:1px solid #555; padding:2px; box-sizing:border-box; }
    .tile, .cell { width:40px; height:40px; border:1px solid #000; margin:2px; line-height:40px; font-size:16px; font-weight:bold; text-align:center; box-sizing:border-box; flex-shrink:0; }
    .tile { background:#fff; cursor:default; }
    #drawnTileArea .tile { margin:0; }
    .highlight { animation: glow 1s infinite alternate; border-color: #07f; }
    .recommended { animation: recommended-glow 0.8s infinite alternate; border-color: #0a0; }
    @keyframes recommended-glow { from { background: rgba(144,238,144,.3); } to { background: rgba(144,238,144,.8); } }
    .cell { background:#f0f0f0; cursor:pointer; }
    .board .cell:nth-child(1),
    .board .cell:nth-child(6),
    .board .cell:nth-child(11),
    .board .cell:nth-child(16) { background:#D0F0FF; }
    #player { font-size:16px; padding:5px; margin-bottom:10px; display:inline-block; width:150px; box-sizing:border-box; }
    p label { display:inline-block; margin-right:5px; }
    p:has(label) { text-align:center; max-width:none; }
    #jokerSelect, #resetBtn, button { margin:10px 5px; font-size:16px; padding:8px 15px; cursor:pointer; }
    #warning { color:#d00; font-weight:bold; min-height:1.2em; margin-bottom:10px; }

    table.score-table { margin:20px auto; border-collapse:collapse; font-size:14px; width:fit-content; }
    .shaded { background:#f2f2f2; }
    @keyframes glow { from { background:#fff; } to { background:#ddd; } }

   /* 랭킹 2열 배치 + 월별 카드 스타일 */
    .rankings-wrap { display:flex; gap:16px; justify-content:center; align-items:flex-start; flex-wrap:wrap; max-width:660px; margin:20px auto; }
    #rankingAreaMonthly { border:1px solid #ccc; padding:20px; background:#f9f9f9; text-align:left; width:300px; }
    .month-control select { padding:4px 8px; }
    /* 랭킹 레이아웃 */
    .rankings-wrap{ display:flex; gap:16px; justify-content:center; align-items:flex-start; flex-wrap:wrap; margin-top:30px; }
    .ranking-card{ width:300px; border:1px solid #ccc; background:#f9f9f9; padding:20px; text-align:left; }
    .ranking-card h3{ text-align:center; margin-bottom:12px; }
    #rankingList, #rankingListMonthly{ list-style:none; padding:0; margin:0; }
    #rankingList li, #rankingListMonthly li{ padding:5px 0; border-bottom:1px dashed #eee; display:flex; justify-content:space-between; }
    #rankingList li:last-child, #rankingListMonthly li:last-child{ border-bottom:none; }
    .rank-name{ font-weight:700; }
    .rank-score{ color:#07f; }
    .rank-date{ font-size:.8em; color:#777; }
    .month-control{ margin-bottom:10px; text-align:center; }
    .month-control select{ padding:4px 8px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>스트림스 웹앱 v15</h1>
    <p>
    <p>스트림스 게임은 40개의 타일 중 20개를 뽑아서 보드에 배치하는 게임입니다.</p>
    <p>타일을 연속하여 오름차순으로 배치할수록 높은 점수를 받습니다.</p>
    <p>숫자가 같은 타일은 오름차순으로 인정됩니다.</p>
    <p>타일을 하나 뽑으면 반드시 보드에 배치를 해야 다음 타일을 뽑을 수 있습니다.</p>
    <p>[다음 타일 뽑기] 버튼을 눌러 1개씩 무작위로 타일을 뽑습니다.</p>
    <p>뽑힌 타일은 반짝이며 강조되고, 20칸 보드 중 원하는 빈 위치에 클릭하여 배치할 수 있습니다.</p>
    <p><strong>[추천 받기] 버튼을 누르면 현재 뽑힌 타일을 어디에 놓아야 가장 높은 점수를 받을지 추천해줍니다.</strong></p>
    <p>☆은 조커이며, 마지막에 1~30까지의 원하는 숫자로 지정됩니다.</p>
    <p>20칸 보드를 모두 채우면 점수가 계산됩니다.</p>

    <h3>🧮 점수표</h3>
    <table class="score-table">
      <tr><td class="shaded">1칸</td><td>0점</td><td class="shaded">2칸</td><td>1점</td><td class="shaded">3칸</td><td>3점</td><td class="shaded">4칸</td><td>5점</td><td class="shaded">5칸</td><td>7점</td></tr>
      <tr><td class="shaded">6칸</td><td>9점</td><td class="shaded">7칸</td><td>11점</td><td class="shaded">8칸</td><td>15점</td><td class="shaded">9칸</td><td>20점</td><td class="shaded">10칸</td><td>25점</td></tr>
      <tr><td class="shaded">11칸</td><td>30점</td><td>12칸</td><td>35점</td><td class="shaded">13칸</td><td>40점</td><td class="shaded">14칸</td><td>50점</td><td class="shaded">15칸</td><td>60점</td></tr>
      <tr><td class="shaded">16칸</td><td>70점</td><td class="shaded">17칸</td><td>85점</td><td class="shaded">18칸</td><td>100점</td><td class="shaded">19칸</td><td>150점</td><td class="shaded">20칸</td><td>300점</td></tr>
    </table>

    <p><label for="player">이름:</label> <input type="text" id="player" /></p>

    <h3>남은 타일</h3>
    <div class="tile-container" id="tileContainer"></div>

    <h3>뽑은 타일 (보드에 배치하세요)</h3>
    <div id="drawnTileArea"></div>

    <button id="drawBtn">다음 타일 뽑기</button>
    <button id="recommendBtn" disabled>추천 받기</button>
    <button id="resetBtn" onclick="location.reload()">처음으로</button>

    <div id="warning"></div>
    <h3>20칸 보드</h3>
    <div class="board" id="board"></div>

    <div id="jokerArea" style="display:none;">
      <label for="jokerSelect">☆ 값을 선택: </label>
      <select id="jokerSelect"></select>
      <button onclick="confirmJoker()">확정</button>
    </div>

    <p id="scoreBreakdown"></p>
    <p>점수: <span id="score">0</span></p>
    <button id="submitBtn" disabled>결과 저장</button>

    <!-- 랭킹 패널: 전체 + 월별 -->
    <div class="rankings-wrap">
      <!-- 전체 랭킹 -->
      <div id="rankingArea" class="ranking-card">
     <h3>🏆 역대 최고 점수 랭킹</h3>
     <ul id="rankingList"></ul>
    </div>

    <!-- 월별 랭킹 -->
    <div id="rankingAreaMonthly" class="ranking-card">
     <h3>📅 월별 랭킹</h3>
     <div class="month-control">
      <label>월 선택: <select id="monthSelect"></select></label>
    </div>
    <ul id="rankingListMonthly"></ul>
  </div>
</div>

  </div>

  <!-- ====== 여기부터: 게임 로직 + 랭킹 연동 ====== -->
  <script>
    /* ---------- 게임 데이터 ---------- */
    const scoreTable = {1:0,2:1,3:3,4:5,5:7,6:9,7:11,8:15,9:20,10:25,11:30,12:35,13:40,14:50,15:60,16:70,17:85,18:100,19:150,20:300};

    let allTiles = [];
    for (let i=1;i<=30;i++){ const c=(i>=11&&i<=19)?2:1; for(let j=0;j<c;j++) allTiles.push(i); }
    allTiles.push('*');

    const tileContainer = document.getElementById("tileContainer");
    const drawnTileArea = document.getElementById("drawnTileArea");
    const board = document.getElementById("board");
    const submitBtn = document.getElementById("submitBtn");
    const jokerArea = document.getElementById("jokerArea");
    const jokerSelect = document.getElementById("jokerSelect");
    const scoreBreakdown = document.getElementById("scoreBreakdown");
    const warning = document.getElementById("warning");
    const drawButton = document.getElementById("drawBtn");
    const recommendBtn = document.getElementById('recommendBtn');
    const rankingList = document.getElementById('rankingList');

    let remainingTiles = [...allTiles];
    let activeTile = null;
    let placedCount = 0;
    let drawOrder = [];
    let currentRecommendationElement = null;

    function renderBoard(){
      board.innerHTML = '';
      for (let i=0;i<20;i++){
        const div=document.createElement('div');
        div.className='cell'; div.dataset.index=i;
        div.addEventListener('click', handleCellClick);
        board.appendChild(div);
      }
    }
    function renderRemainingTiles(){
      tileContainer.innerHTML='';
      remainingTiles.forEach(num=>{
        const div=document.createElement('div');
        div.className='tile';
        div.textContent = (num==='*')?'☆':num;
        tileContainer.appendChild(div);
      });
    }

    function getScoreFromBoard(arr){
      let total=0, len=0, last=-Infinity;
      for (let i=0;i<arr.length;i++){
        const v=parseInt(arr[i],10);
        if (isNaN(v)){ if (len>1) total+= (scoreTable[len]||0); len=0; last=-Infinity; continue; }
        if (len===0 || v>=last){ len++; } else { if (len>1) total+=(scoreTable[len]||0); len=1; }
        last=v;
      }
      if (len>1) total+=(scoreTable[len]||0);
      return total;
    }

    function drawNextTile(){
      if (activeTile){ warning.textContent="뽑은 타일을 먼저 배치하세요."; return; }
      if (placedCount>=20){ drawButton.disabled=true; return; }
      if (!remainingTiles.length){ warning.textContent="타일이 없습니다."; return; }
      warning.textContent="";

      const idx=Math.floor(Math.random()*remainingTiles.length);
      const val=remainingTiles[idx];
      drawOrder.push(val);
      const tileEl=tileContainer.children[idx];
      if (!tileEl){ warning.textContent="오류: 타일 요소를 찾을 수 없습니다."; return; }
      drawnTileArea.appendChild(tileEl);
      tileEl.classList.add('highlight');
      remainingTiles.splice(idx,1);
      renderRemainingTiles();
      activeTile={value:val};
      drawButton.disabled=true; recommendBtn.disabled=false;
    }
    drawButton.addEventListener('click', drawNextTile);

    function handleCellClick(e){
      const cell=e.target;
      if (activeTile && cell.textContent===''){
        cell.textContent = (activeTile.value==='*')?'☆':activeTile.value;
        cell.classList.add('placed');
        drawnTileArea.innerHTML='';
        placedCount++; activeTile=null; warning.textContent="";
        removeRecommendationHighlight();
        if (placedCount<20){ drawButton.disabled=false; recommendBtn.disabled=true; }
        else { drawButton.disabled=true; recommendBtn.disabled=true; setTimeout(endGame, 100); }
      } else if (!activeTile){ warning.textContent="먼저 타일을 뽑아주세요."; }
      else if (cell.textContent!==''){ warning.textContent="이미 놓인 칸입니다."; }
    }

    function endGame(){
      warning.textContent="보드가 다 채워졌습니다!";
      const hasJoker = Array.from(board.children).some(c=>c.textContent==='☆');
      if (hasJoker){
        jokerArea.style.display='block';
        jokerSelect.innerHTML='';
        for (let i=1;i<=30;i++){ const o=document.createElement('option'); o.value=i; o.textContent=i; jokerSelect.appendChild(o); }
        jokerSelect.value=15;
        warning.textContent="조커 값을 선택해주세요.";
      } else { calculateScore(); }
    }

    function confirmJoker(){
      const v=parseInt(jokerSelect.value,10);
      const cell=Array.from(board.children).find(c=>c.textContent==='☆');
      if (cell && !isNaN(v)){ cell.textContent=v; } else { warning.textContent="조커 값을 올바르게 선택해주세요."; return; }
      jokerArea.style.display='none'; warning.textContent=""; calculateScore();
    }

    function calculateScore(){
      const vals = Array.from(board.children).map(c=>c.textContent);
      const total = getScoreFromBoard(vals);
      document.getElementById('score').textContent = total;

      // 간단한 구간 설명
      let breakdown="점수 상세: ";
      let len=0, last=-Infinity, seq=[]; const parts=[];
      for (const t of vals){
        const v=parseInt(t,10);
        if (isNaN(v)){ if (len>1){ parts.push(`[${seq.join('→')}] ${len}칸(${scoreTable[len]||0}점)`); } len=0; last=-Infinity; seq=[]; continue; }
        if (len===0 || v>=last){ len++; seq.push(v); } else { if (len>1){ parts.push(`[${seq.join('→')}] ${len}칸(${scoreTable[len]||0}점)`);} len=1; seq=[v]; }
        last=v;
      }
      if (len>1){ parts.push(`[${seq.join('→')}] ${len}칸(${scoreTable[len]||0}점)`); }
      breakdown += parts.join(' + ') || "연속 구간 없음(2칸 이상)";
      scoreBreakdown.textContent = breakdown;
      submitBtn.disabled=false;
    }

    submitBtn.addEventListener('click', submitResult);
    function submitResult(){
      const playerName = (document.getElementById('player').value || '').trim() || '익명';
      const finalScore = parseInt(document.getElementById('score').textContent||'0',10);
      const finalBoardState = Array.from(board.children).map(c=>c.textContent);
      const drawOrderState = drawOrder.map(v=>v==='*'?'☆':v);
      alert(`${playerName}님의 최종 점수는 ${finalScore}점입니다!`);
      saveRanking(playerName, finalScore); // 로컬
      gasSave({name:playerName, score:finalScore, tiles:finalBoardState, order:drawOrderState, date:new Date().toLocaleString('ko-KR',{year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit'})})
        .then(()=> refreshRanking());
    }

    /* ---------- 로컬 랭킹 (폴백) ---------- */
    const RANKING_KEY='streams_rankings';
    function getRankings(){ const s=localStorage.getItem(RANKING_KEY); return s?JSON.parse(s):[]; }
    function saveRanking(name,score){
      let arr=getRankings();
      arr.push({name,score,date:new Date().toLocaleString('ko-KR',{year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit'})});
      arr.sort((a,b)=>(b.score===a.score)?(new Date(a.date)-new Date(b.date)):(b.score-a.score));
      arr=arr.slice(0,10); localStorage.setItem(RANKING_KEY, JSON.stringify(arr)); displayRanking();
    }
    function displayRanking(){
      const ul=rankingList; ul.innerHTML='';
      const arr=getRankings();
      if (!arr.length){ ul.innerHTML='<li>아직 랭킹이 없습니다.</li>'; return; }
      arr.forEach((e,i)=>{
        const li=document.createElement('li');
        li.innerHTML=`<span class="rank-name">${i+1}. ${e.name}</span><span><span class="rank-score">${e.score}점</span> <span class="rank-date">(${e.date})</span></span>`;
        ul.appendChild(li);
      });
    }

    /* ---------- GAS 저장 엔드포인트 ---------- */
    const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbzu8RE7GqIQdZeRUG2cW2qe_FWomSjlOGqsLMEVi6369gw1xtqq2J6ZD5xPQKKaLubqLQ/exec';
    async function gasSave({name, score, tiles, order, date}){
      try{
        if (!GAS_ENDPOINT) return;
        const params = new URLSearchParams({ action:'save', name:String(name||'익명'), score:String(score||0),
                                             tiles:Array.isArray(tiles)?tiles.join(','):String(tiles||''),
                                             order:Array.isArray(order)?order.join(','):String(order||''),
                                             date:String(date||'') });
        await fetch(`${GAS_ENDPOINT}?${params.toString()}`, {method:'GET'});
      }catch(e){ console.warn('GAS save failed:', e); }
    }

    /* ---------- GViz 조회 (전체/월별) ---------- */
    const SHEET_ID   = '1jBL_ZHXPJUCCopdPm-SVjmQLDw_zoQHoO6K9vJ95CiI';
    const SHEET_NAME = '스트림스';
    async function gasFetchTop(){
      const url=`https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(SHEET_NAME)}&range=A2:D`;
      const res=await fetch(url,{method:'GET'}); if(!res.ok) throw new Error('HTTP '+res.status);
      const txt=await res.text(); const match=txt.match(/\{[\s\S]*\}/); if(!match) throw new Error('Failed to parse GViz JSON');
      const data=JSON.parse(match[0]);
      const rows=(data.table?.rows||[]).map(r=>({
        index:r.c?.[0]?.v ?? '',
        date:(r.c?.[1]?.f ?? r.c?.[1]?.v ?? ''),
        name:r.c?.[2]?.v ?? '익명',
        score:Number(r.c?.[3]?.v ?? 0)
      })).filter(r=>!Number.isNaN(r.score));
      rows.sort((a,b)=>(b.score===a.score)?String(a.date).localeCompare(String(b.date)):(b.score-a.score));
      return rows.slice(0,50); // 상위 50까지 받아두고 필터링에서 10개 사용
    }

    function escapeHtml(s){ return String(s).replace(/[&<>\"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

    function renderServerRanking(rows){
      const ul=document.getElementById('rankingList'); if(!ul) return; ul.innerHTML='';
      if(!rows || !rows.length){ ul.innerHTML='<li>서버 랭킹이 없습니다.</li>'; return; }
      rows.slice(0,10).forEach((r,i)=>{
        const li=document.createElement('li');
        const d=r.date||r.saved_at||'';
        li.innerHTML=`<span class="rank-name">${i+1}. ${escapeHtml(r.name||'익명')}</span><span><span class="rank-score">${escapeHtml(r.score)}</span> <span class="rank-date">(${escapeHtml(d)})</span></span>`;
        const s=li.querySelector('.rank-score'); if(s && !/점$/.test(s.textContent)) s.textContent+= '점';
        ul.appendChild(li);
      });
    }

    function monthKeyFrom(dateStr){ const s=String(dateStr||''); const m=s.match(/^(\d{4})[-/.](\d{1,2})/); if(!m) return ''; return `${m[1]}-${String(m[2]).padStart(2,'0')}`; }
    function buildMonthOptions(rows){
      const sel=document.getElementById('monthSelect'); if(!sel) return;
      const keys=Array.from(new Set(rows.map(r=>monthKeyFrom(r.date||r.saved_at)).filter(Boolean)));
      keys.sort((a,b)=>b.localeCompare(a));
      sel.innerHTML='';
      const now=new Date(); const currentKey=`${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}`;
      keys.forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=k; sel.appendChild(o); });
      if (keys.includes(currentKey)) sel.value=currentKey; else if(keys.length) sel.value=keys[0];
    }
    function renderMonthlyRankingFor(monthKey, rows){
      const ul=document.getElementById('rankingListMonthly'); if(!ul) return; ul.innerHTML='';
      const monthly=rows.filter(r=>monthKeyFrom(r.date||r.saved_at)===monthKey);
      if(!monthly.length){ ul.innerHTML='<li>이 달의 랭킹이 없습니다.</li>'; return; }
      monthly.slice(0,10).forEach((r,i)=>{
        const li=document.createElement('li'); const d=r.date||r.saved_at||'';
        li.innerHTML=`<span class="rank-name">${i+1}. ${escapeHtml(r.name||'익명')}</span><span><span class="rank-score">${escapeHtml(r.score)}</span> <span class="rank-date">(${escapeHtml(d)})</span></span>`;
        const s=li.querySelector('.rank-score'); if(s && !/점$/.test(s.textContent)) s.textContent+='점';
        ul.appendChild(li);
      });
    }

    async function refreshRanking(){
      try{
        const data=await gasFetchTop();
        renderServerRanking(data); // 전체
        buildMonthOptions(data);
        const sel=document.getElementById('monthSelect');
        if (sel && sel.value){ renderMonthlyRankingFor(sel.value, data); sel.onchange=()=>renderMonthlyRankingFor(sel.value,data); }
      }catch(e){
        console.warn('Server ranking unavailable, falling back to local ranking.', e);
        if (typeof displayRanking==='function') displayRanking();
      }
    }

    // 초기 렌더
    document.addEventListener('DOMContentLoaded', ()=>{
      renderRemainingTiles(); renderBoard(); drawButton.disabled=false; recommendBtn.disabled=true; submitBtn.disabled=true;
      displayRanking(); // 로컬 폴백 먼저
      refreshRanking(); // 서버 시도
    });
  </script>

<script>
/* ===== 월별 랭킹 전용 코드 (기존 코드와 독립) ===== */

/* 날짜 "YYYY-MM" 키 뽑기 */
function monthKeyFrom(dateStr){
  const s = String(dateStr || '');
  const m = s.match(/^(\d{4})[-/.](\d{1,2})/);
  if (!m) return '';
  return `${m[1]}-${String(m[2]).padStart(2,'0')}`;
}

/* GViz 전체 행 읽기: 기존 gasFetchTop은 상위 10개만이므로, 월별용으로 전체를 새로 읽습니다 */
async function gasFetchAllRows(){
  // 기존 GAS 블록에서 쓰는 상수 재사용 (이미 파일 하단에 선언되어 있음)
  // const SHEET_ID = '...'; const SHEET_NAME = '...';
  const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(SHEET_NAME)}&range=A2:D`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('HTTP ' + res.status);
  const txt = await res.text();
  const match = txt.match(/\{[\s\S]*\}/);
  if(!match) throw new Error('Failed to parse GViz JSON');
  const data = JSON.parse(match[0]);

  // A=index, B=saved_at, C=name, D=score
  const rows = (data.table?.rows || []).map(r => ({
    index : r.c?.[0]?.v ?? '',
    date  : (r.c?.[1]?.f ?? r.c?.[1]?.v ?? ''),
    name  : r.c?.[2]?.v ?? '익명',
    score : Number(r.c?.[3]?.v ?? 0)
  })).filter(r => !Number.isNaN(r.score));

  // 점수 내림차순, 동점시 날짜 오름차순
  rows.sort((a,b) => (b.score === a.score) ? String(a.date).localeCompare(String(b.date)) : b.score - a.score);
  return rows; // 전체 반환
}

/* 드롭다운 옵션 만들기 (이번 달 우선 선택) */
function buildMonthOptions(rows){
  const sel = document.getElementById('monthSelect');
  if (!sel) return;
  const keys = [...new Set(rows.map(r => monthKeyFrom(r.date)).filter(Boolean))].sort((a,b)=>b.localeCompare(a));
  sel.innerHTML = '';
  keys.forEach(k => {
    const opt = document.createElement('option');
    opt.value = k; opt.textContent = k; sel.appendChild(opt);
  });
  const now = new Date();
  const current = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}`;
  if (keys.includes(current)) sel.value = current;
  else if (keys.length) sel.value = keys[0];
}

/* 선택된 월의 Top10 렌더 */
function renderMonthlyRankingFor(monthKey, rows){
  const ul = document.getElementById('rankingListMonthly');
  if (!ul) return;
  ul.innerHTML = '';
  const monthly = rows.filter(r => monthKeyFrom(r.date) === monthKey).slice(0,10);
  if (!monthly.length){
    ul.innerHTML = '<li>이 달의 랭킹이 없습니다.</li>';
    return;
  }
  monthly.forEach((r,i) => {
    const li = document.createElement('li');
    const d = r.date || '';
    li.innerHTML = `
      <span class="rank-name">${i+1}. ${r.name}</span>
      <span><span class="rank-score">${r.score}점</span> <span class="rank-date">(${d})</span></span>`;
    ul.appendChild(li);
  });
}

/* 페이지 로드 시 월별 랭킹 초기화 (전체 랭킹 로직은 기존 코드 유지) */
document.addEventListener('DOMContentLoaded', async () => {
  try{
    const rows = await gasFetchAllRows();  // 전체 데이터
    buildMonthOptions(rows);
    const sel = document.getElementById('monthSelect');
    if (sel && sel.options && sel.options.length){
      renderMonthlyRankingFor(sel.value, rows);
      sel.onchange = () => renderMonthlyRankingFor(sel.value, rows);
    }
  }catch(e){
    console.warn('월별 랭킹 불러오기 실패:', e);
    const ul = document.getElementById('rankingListMonthly');
    if (ul) ul.innerHTML = '<li>월별 데이터 로딩 실패</li>';
  }
});
</script>
</body>
</html>
