<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>스트림스 웹앱 v15 랭킹시스템</title>
  <style>
    body {
      background-color: white;
      color: black;
      font-family: sans-serif;
      text-align: center;
      overflow-x: auto;
      padding-bottom: 50px;
      margin: 0;
    }
    .container {
        width: fit-content;
        margin: 0 auto;
        padding: 20px;
    }
    h1, h3, p, table, button, #jokerArea {
         margin-left: auto;
         margin-right: auto;
         width: fit-content;
    }
    p:not(:has(label)) {
         text-align: left;
         max-width: 600px;
         margin-left: auto;
         margin-right: auto;
    }

    .tile-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 10px;
      margin-bottom: 10px;
      width: 250px;
      min-height: 48px;
      border: 1px dashed #eee;
      padding: 5px;
      box-sizing: border-box;
    }
    #drawnTileArea {
        min-height: 48px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 10px;
        margin-bottom: 10px;
        width: 250px;
        border: 1px dashed #ccc;
        box-sizing: border-box;
    }
    .board {
      display: flex;
      justify-content: flex-start;
      margin-top: 20px;
      margin-bottom: 20px;
      width: 880px;
      border: 1px solid #555;
      padding: 2px;
      box-sizing: border-box;
    }

    .tile, .cell {
      width: 40px;
      height: 40px;
      border: 1px solid black;
      margin: 2px;
      line-height: 40px;
      font-size: 16px;
      font-weight: bold;
      text-align: center;
      box-sizing: border-box;
      flex-shrink: 0;
    }
    .tile {
      background-color: white;
      cursor: default;
    }
    #drawnTileArea .tile {
         cursor: default;
         margin: 0;
    }

    .highlight {
      animation: glow 1s infinite alternate;
      border-color: blue;
    }
    .recommended {
        animation: recommended-glow 0.8s infinite alternate;
        border-color: green;
    }
    @keyframes recommended-glow {
        from { background-color: rgba(144, 238, 144, 0.3); }
        to { background-color: rgba(144, 238, 144, 0.8); }
    }

    .cell {
      background-color: #f0f0f0;
      cursor: pointer;
    }
    .board .cell:nth-child(1),
    .board .cell:nth-child(6),
    .board .cell:nth-child(11),
    .board .cell:nth-child(16) {
        background-color: #D0F0FF;
    }

    #player {
        font-size: 16px;
        padding: 5px;
        margin-bottom: 10px;
        display: inline-block;
        width: 150px;
        box-sizing: border-box;
    }
    p label {
        display: inline-block;
        margin-right: 5px;
    }
    p:has(label) {
        text-align: center;
        max-width: none;
    }

    #jokerSelect, #resetBtn, button {
      margin: 10px 5px;
      font-size: 16px;
      padding: 8px 15px;
      cursor: pointer;
    }
    #warning {
      color: red;
      font-weight: bold;
      min-height: 1.2em;
      margin-bottom: 10px;
    }
    table.score-table {
      margin: 20px auto;
      border-collapse: collapse;
      font-size: 14px;
      width: fit-content;
    }
    .shaded {
      background-color: #f2f2f2;
    }
    @keyframes glow {
      from { background-color: #fff; }
      to { background-color: #ddd; }
    }
    /* 랭킹 스타일 */
    #rankingArea {
        margin-top: 40px;
        border: 1px solid #ccc;
        padding: 20px;
        background-color: #f9f9f9;
        text-align: left;
        width: 300px;
        margin-left: auto;
        margin-right: auto;
    }
    #rankingArea h3 {
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    }
    #rankingList {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    #rankingList li {
        padding: 5px 0;
        border-bottom: 1px dashed #eee;
        display: flex;
        justify-content: space-between;
    }
    #rankingList li:last-child {
        border-bottom: none;
    }
    #rankingList .rank-name {
        font-weight: bold;
    }
    #rankingList .rank-score {
        color: #007bff;
    }
    #rankingList .rank-date {
        font-size: 0.8em;
        color: #777;
    }

    /* 중앙 정렬 보정 */
   #tileContainer, #drawnTileArea, .board { 
    margin-left: auto; 
    margin-right: auto; 
    }
   #drawnTileArea { display:flex; justify-content:center; align-items:center; }
   body, .container { text-align: center; }

  .rankings-wrap{ display:flex; gap:16px; justify-content:center; align-items:flex-start; flex-wrap:wrap; max-width:660px; margin:20px auto; }
  .ranking-card{ width:300px; border:1px solid #ccc; background:#f9f9f9; padding:20px; text-align:left; }
  #rankingList, #rankingListMonthly{ list-style:none; padding:0; margin:0; }
  #rankingList li, #rankingListMonthly li{ padding:5px 0; border-bottom:1px dashed #eee; display:flex; justify-content:space-between; }
  #rankingList li:last-child, #rankingListMonthly li:last-child{ border-bottom:none; }
  .month-control{ margin-bottom:10px; text-align:center; }
  .month-control select{ padding:4px 8px; }


  </style>
</head>
<body>
  <div class="container">
      <h1>스트림스 웹앱 v15</h1>
      <p>
        스트림스 게임은 40개의 타일 중 20개를 뽑아서 보드에 배치하는 게임입니다.<br>
        타일을 연속하여 오름차순으로 배치할수록 높은 점수를 받습니다.<br>
        숫자가 같은 타일은 오름차순으로 인정됩니다.<br>
        타일을 하나 뽑으면 반드시 20칸 보드에 배치를 해야 다음 타일을 뽑을 수 있습니다.<br>
        [다음 타일 뽑기] 버튼을 눌러 1개씩 무작위로 타일을 뽑습니다.<br>
        뽑힌 타일은 반짝이며 강조되고, 20칸 보드 중 원하는 빈 위치에 클릭하여 배치할 수 있습니다.<br>
        **[추천 받기] 버튼을 누르면 현재 뽑힌 타일을 어디에 놓아야 가장 높은 점수를 받을지 추천해줍니다.**<br>
        ☆은 조커이며, 마지막에 1~30까지의 원하는 숫자로 지정됩니다.<br>
        20칸 보드를 모두 채우면 점수가 계산됩니다.
      </p>
      <h3>🧮 오름차순 배치 칸 수별 점수표</h3>
      <table class="score-table">
        <tr><td class="shaded">1칸</td><td>0점</td><td class="shaded">2칸</td><td>1점</td><td class="shaded">3칸</td><td>3점</td><td class="shaded">4칸</td><td>5점</td><td class="shaded">5칸</td><td>7점</td></tr>
        <tr><td class="shaded">6칸</td><td>9점</td><td class="shaded">7칸</td><td>11점</td><td class="shaded">8칸</td><td>15점</td><td class="shaded">9칸</td><td>20점</td><td class="shaded">10칸</td><td>25점</td></tr>
        <tr><td class="shaded">11칸</td><td>30점</td><td>12칸</td><td>35점</td><td class="shaded">13칸</td><td>40점</td><td class="shaded">14칸</td><td>50점</td><td class="shaded">15칸</td><td>60점</td></tr>
        <tr><td class="shaded">16칸</td><td>70점</td><td class="shaded">17칸</td><td>85점</td><td class="shaded">18칸</td><td>100점</td><td class="shaded">19칸</td><td>150점</td><td class="shaded">20칸</td><td>300점</td></tr>
      </table>

      <p><label for="player">이름:</label> <input type="text" id="player" /></p>

      <h3>남은 타일</h3>
      <div class="tile-container" id="tileContainer"></div>

      <h3>뽑은 타일 (보드에 배치하세요)</h3>
      <div id="drawnTileArea"></div>

      <button onclick="drawNextTile()">다음 타일 뽑기</button>
      <button onclick="recommendPlacement()" id="recommendBtn" disabled>추천 받기</button>
      <button onclick="location.reload()" id="resetBtn">처음으로</button>

      <div id="warning"></div>
      <h3>20칸 보드</h3>
      <div class="board" id="board"></div>

      <div id="jokerArea" style="display:none;">
        <label for="jokerSelect">☆를 어떤 숫자로 간주하시겠습니까? </label>
        <select id="jokerSelect"></select>
        <button onclick="confirmJoker()">확정</button>
      </div>

      <p id="scoreBreakdown"></p>
      <p>점수: <span id="score">0</span></p>

      <button onclick="submitResult()" disabled id="submitBtn">결과 저장</button>

  <!-- 랭킹 패널: 전체 + 월별 -->
 <div class="rankings-wrap">
   <div id="rankingArea" class="ranking-card">
    <h3>🏆 역대 최고 점수 랭킹</h3>
    <ul id="rankingList"></ul>
   </div>

   <div id="rankingAreaMonthly" class="ranking-card">
     <h3>📅 월별 랭킹</h3>
     <div class="month-control">
       <label>월 선택: <select id="monthSelect"></select></label>
     </div>
     <ul id="rankingListMonthly"></ul>
   </div>
  </div>

  <script>
    const scoreTable = {
      1: 0, 2: 1, 3: 3, 4: 5, 5: 7, 6: 9, 7: 11, 8: 15, 9: 20, 10: 25,
      11: 30, 12: 35, 13: 40, 14: 50, 15: 60, 16: 70, 17: 85, 18: 100, 19: 150, 20: 300
    };

    let allTiles = [];
    for (let i = 1; i <= 30; i++) {
      const count = (i >= 11 && i <= 19) ? 2 : 1;
      for (let j = 0; j < count; j++) allTiles.push(i);
    }
    allTiles.push('*');

    const tileContainer = document.getElementById("tileContainer");
    const drawnTileArea = document.getElementById("drawnTileArea");
    const board = document.getElementById("board");
    const submitBtn = document.getElementById("submitBtn");
    const jokerArea = document.getElementById("jokerArea");
    const jokerSelect = document.getElementById("jokerSelect");
    const scoreBreakdown = document.getElementById("scoreBreakdown");
    const warning = document.getElementById("warning");
    const drawButton = document.querySelector('button');
    const recommendBtn = document.getElementById('recommendBtn');
    const rankingList = document.getElementById('rankingList');

    let remainingTiles = [...allTiles];
    let activeTile = null;
    let placedCount = 0;
    let drawOrder = [];
    let currentRecommendationElement = null;

    const idealCellRanges = [
        [1, 2],
        [3, 4],
        [5, 6],
        [7, 8],
        [9, 10],
        [11, 11],
        [12, 12],
        [13, 13],
        [14, 14],
        [15, 15],
        [16, 16],
        [17, 17],
        [18, 18],
        [19, 19],
        [20, 21],
        [22, 23],
        [24, 25],
        [26, 27],
        [28, 29],
        [30, 30]
    ];

    function renderBoard() {
        board.innerHTML = '';
        for (let i = 0; i < 20; i++) {
            const div = document.createElement("div");
            div.className = "cell";
            div.dataset.index = i;
            div.addEventListener('click', handleCellClick);
            board.appendChild(div);
        }
    }

    function renderRemainingTiles() {
        tileContainer.innerHTML = '';
        remainingTiles.forEach((num) => {
            const div = document.createElement("div");
            div.className = "tile";
            div.textContent = num === '*' ? '☆' : num;
            tileContainer.appendChild(div);
        });
    }

    function getScoreFromBoard(boardElementsArray) {
        let currentScore = 0;
        let currentSequenceLength = 0;
        let lastValue = -Infinity;

        for (let i = 0; i < boardElementsArray.length; i++) {
            const cellValue = parseInt(boardElementsArray[i], 10);

            if (isNaN(cellValue)) {
                 if (currentSequenceLength > 1) {
                     currentScore += scoreTable[currentSequenceLength] || 0;
                 }
                 currentSequenceLength = 0;
                 lastValue = -Infinity;
                 continue;
            }

            if (currentSequenceLength === 0 || cellValue >= lastValue) {
                currentSequenceLength++;
            } else {
                if (currentSequenceLength > 1) {
                    currentScore += scoreTable[currentSequenceLength] || 0;
                }
                currentSequenceLength = 1;
            }
            lastValue = cellValue;
        }

        if (currentSequenceLength > 1) {
            currentScore += scoreTable[currentSequenceLength] || 0;
        }
        return currentScore;
    }

    function getIdealFitScore(placedValue, index) {
        const idealRange = idealCellRanges[index];
        if (!idealRange) return 0;

        const [minIdeal, maxIdeal] = idealRange;

        if (placedValue >= minIdeal && placedValue <= maxIdeal) {
            return 10000;
        } else {
            let distanceToRange = Math.min(Math.abs(placedValue - minIdeal), Math.abs(placedValue - maxIdeal));
            return Math.max(0, 1000 - distanceToRange * 100);
        }
    }

    // 버리는 칸의 전략적 가치를 평가하는 함수
    function evaluateDiscardPotential(tempBoardState, index, placedValue, originalBoardState) {
        let discardScore = 0;

        // 1. 현재 놓은 곳의 점수 변화 (음수도 고려)
        const currentOverallScore = getScoreFromBoard(originalBoardState);
        const simulatedOverallScore = getScoreFromBoard(tempBoardState);
        discardScore += simulatedOverallScore - currentOverallScore;

        // 2. 버리는 타일의 위치 적합성
        if (index === 0) discardScore += (placedValue <= 15) ? 1000 : 10;
        else if (index === 19) discardScore += (placedValue > 15) ? 1000 : 10;
        else discardScore += 10;

        // 3. 미래 시퀀스 파괴 최소화
        let originalSequenceCount = 0;
        let newSequenceCount = 0;

        let currentSequenceLength = 0;
        let lastValue = -Infinity;
        for (let i = 0; i < 20; i++) {
            const val = parseInt(originalBoardState[i], 10);
            if (isNaN(val)) {
                if (currentSequenceLength > 1) originalSequenceCount++;
                currentSequenceLength = 0;
                lastValue = -Infinity;
                continue;
            }
            if (val >= lastValue) currentSequenceLength++;
            else { if (currentSequenceLength > 1) originalSequenceCount++; currentSequenceLength = 1; }
            lastValue = val;
        }
        if (currentSequenceLength > 1) originalSequenceCount++;

        currentSequenceLength = 0;
        lastValue = -Infinity;
        for (let i = 0; i < 20; i++) {
            const val = parseInt(tempBoardState[i], 10);
            if (isNaN(val)) {
                if (currentSequenceLength > 1) newSequenceCount++;
                currentSequenceLength = 0;
                lastValue = -Infinity;
                continue;
            }
            if (val >= lastValue) currentSequenceLength++;
            else { if (currentSequenceLength > 1) newSequenceCount++; currentSequenceLength = 1; }
            lastValue = val;
        }
        if (currentSequenceLength > 1) newSequenceCount++;

        discardScore -= (originalSequenceCount - newSequenceCount) * 100;

        return discardScore;
    }

    function recommendPlacement() {
        if (activeTile === null) {
            warning.textContent = "추천할 타일이 없습니다. '다음 타일 뽑기'를 눌러주세요.";
            return;
        }

        if (activeTile.value === '*') {
            warning.textContent = "조커(☆)는 다양한 숫자가 될 수 있어서 최적의 위치를 찾는 계산이 매우 복잡해요. 직접 배치하는 게 더 좋을 수도 있습니다!";
            return;
        }

        warning.textContent = "";
        removeRecommendationHighlight();

        let currentBoardState = Array.from(board.children).map(cell => cell.textContent);
        const initialOverallScore = getScoreFromBoard(currentBoardState);

        let viableCandidates = [];

        for (let i = 0; i < 20; i++) {
            if (currentBoardState[i] === '') {
                let tempBoardState = [...currentBoardState];
                tempBoardState[i] = activeTile.value;

                // 1. 오름차순 규칙 유지 확인
                let prevVal = (i > 0 && !isNaN(parseInt(currentBoardState[i-1]))) ? parseInt(currentBoardState[i-1]) : -Infinity;
                let nextVal = (i < 19 && !isNaN(parseInt(currentBoardState[i+1]))) ? parseInt(currentBoardState[i+1]) : Infinity;

                if (!(activeTile.value >= prevVal && activeTile.value <= nextVal)) {
                    continue;
                }

                // 2. 점수 변화 계산
                let simulatedScore = getScoreFromBoard(tempBoardState);
                let scoreGain = simulatedScore - initialOverallScore;

                if (scoreGain < 0) {
                    continue;
                }

                // 3. 담당 숫자 범위 적합성 가중치
                const idealFitScore = getIdealFitScore(activeTile.value, i);
                const finalEvaluationScore = (idealFitScore * 1000000000) + scoreGain;

                viableCandidates.push({
                    index: i,
                    scoreGain: scoreGain,
                    idealFitScore: idealFitScore,
                    finalEvaluationScore: finalEvaluationScore
                });
            }
        }

        let bestCandidate = null;
        let recommendationMessage = '';

        if (viableCandidates.length > 0) {
            bestCandidate = viableCandidates.reduce((prev, current) =>
                (prev.finalEvaluationScore > current.finalEvaluationScore ? prev : current)
            );

            let topCandidates = viableCandidates.filter(cand => cand.finalEvaluationScore === bestCandidate.finalEvaluationScore);

            if (topCandidates.length > 1) {
                topCandidates.sort((a, b) => b.scoreGain - a.scoreGain);
                let candidatesWithHighestScoreGain = topCandidates.filter(cand => cand.scoreGain === topCandidates[0].scoreGain);

                let bestGapCandidate = null;
                let maxGapWidth = -Infinity;

                for (const cand of candidatesWithHighestScoreGain) {
                    const i = cand.index;
                    const prevCellFilled = (i > 0 && currentBoardState[i-1] !== '');
                    const nextCellFilled = (i < 19 && currentBoardState[i+1] !== '');

                    if (prevCellFilled && nextCellFilled) {
                        let prevVal = parseInt(currentBoardState[i-1]);
                        let nextVal = parseInt(currentBoardState[i+1]);
                        const currentGapWidth = nextVal - prevVal;
                        if (currentGapWidth > maxGapWidth) {
                            maxGapWidth = currentGapWidth;
                            bestGapCandidate = cand;
                        }
                    }
                }

                if (bestGapCandidate) {
                    bestCandidate = bestGapCandidate;
                } else {
                    bestCandidate = candidatesWithHighestScoreGain.reduce((prev, current) =>
                        (prev.index > current.index ? prev : current)
                    );
                }
            }
            recommendationMessage = `현재 타일을 놓을 만한 곳은 ${bestCandidate.index + 1}번 칸(예상 점수 변화: ${bestCandidate.scoreGain > 0 ? '+' : ''}${bestCandidate.scoreGain}점) 입니다!`;

        } else {
            // 정상 배치 불가 → 버리는 칸 전략
            let discardCandidates = [];
            for (let i = 0; i < 20; i++) {
                if (currentBoardState[i] === '') {
                    let tempBoardState = [...currentBoardState];
                    tempBoardState[i] = activeTile.value;

                    let discardEvalScore = evaluateDiscardPotential(tempBoardState, i, activeTile.value, currentBoardState);

                    discardCandidates.push({
                        index: i,
                        evaluationScore: discardEvalScore
                    });
                }
            }

            if (discardCandidates.length > 0) {
                bestCandidate = discardCandidates.reduce((prev, current) => (prev.evaluationScore > current.evaluationScore ? prev : current));

                let tempBoardStateForMessage = [...currentBoardState];
                tempBoardStateForMessage[bestCandidate.index] = activeTile.value;

                let discardScoreGain = getScoreFromBoard(tempBoardStateForMessage) - initialOverallScore;

                let discardDetails = [];
                let isAscendingViolation = false;
                let prevValForDiscard = (bestCandidate.index > 0 && !isNaN(parseInt(currentBoardState[bestCandidate.index-1]))) ? parseInt(currentBoardState[bestCandidate.index-1]) : -Infinity;
                let nextValForDiscard = (bestCandidate.index < 19 && !isNaN(parseInt(currentBoardState[bestCandidate.index+1]))) ? parseInt(currentBoardState[bestCandidate.index+1]) : Infinity;

                if (!(activeTile.value >= prevValForDiscard && activeTile.value <= nextValForDiscard)) {
                    isAscendingViolation = true;
                    discardDetails.push("오름차순 규칙 위반");
                }
                if (discardScoreGain < 0) {
                    discardDetails.push(`점수 ${discardScoreGain}점 감소`);
                }
                if (discardScoreGain >= 0 && !isAscendingViolation) {
                    discardDetails.push("이 칸은 점수 손실 및 오름차순 위반이 없습니다 (버리기 아까운 칸).");
                }

                recommendationMessage = `정상적인 배치를 찾을 수 없습니다. ${bestCandidate.index + 1}번 칸에 배치하여 버리는 것을 추천합니다. (세부: ${discardDetails.length > 0 ? discardDetails.join(', ') : '전략적 버리기'})`;
                bestCandidate.scoreGain = discardScoreGain;

            } else {
                warning.textContent = "타일을 배치할 수 있는 빈 칸이 없습니다. (모든 칸이 채워져 있습니다)";
                return;
            }
        }

        if (bestCandidate) {
            highlightRecommendation(board.children[bestCandidate.index]);
            warning.textContent = recommendationMessage;
        } else {
            warning.textContent = "타일을 배치할 수 있는 최적의 위치를 찾을 수 없습니다. (알 수 없는 오류)";
        }
    }

    function highlightRecommendation(element) {
        removeRecommendationHighlight();
        currentRecommendationElement = element;
        if (currentRecommendationElement) {
            currentRecommendationElement.classList.add('recommended');
        }
    }

    function removeRecommendationHighlight() {
        if (currentRecommendationElement) {
            currentRecommendationElement.classList.remove('recommended');
            currentRecommendationElement = null;
        }
    }

    function drawNextTile() {
      if (activeTile !== null) {
        warning.textContent = " 뽑은 타일을 먼저 보드에 배치해야 합니다.";
        return;
      }
      if (placedCount >= 20) {
           warning.textContent = "보드가 다 채워졌습니다. 점수 계산을 확인하세요.";
           drawButton.disabled = true;
           return;
       }
      if (remainingTiles.length === 0 && placedCount < 20) {
           warning.textContent = "오류: 게임 진행에 필요한 타일이 부족합니다.";
           drawButton.disabled = true;
           return;
      }

      warning.textContent = "";
      removeRecommendationHighlight();

      const idxToDraw = Math.floor(Math.random() * remainingTiles.length);
      const drawnValue = remainingTiles[idxToDraw];

      // 기록: 뽑은 순서 저장
      if (Array.isArray(drawOrder)) { drawOrder.push(drawnValue); }

      const drawnTileElement = tileContainer.children[idxToDraw];
      if (!drawnTileElement) {
           console.error("Drawn tile element not found at index", idxToDraw, "Remaining:", remainingTiles);
           warning.textContent = "오류: 뽑은 타일 요소를 찾을 수 없습니다.";
          return;
      }

      drawnTileArea.appendChild(drawnTileElement);
      drawnTileElement.classList.add('highlight');

      remainingTiles.splice(idxToDraw, 1);

      activeTile = { value: drawnValue };

      renderRemainingTiles();

      drawButton.disabled = true;
      recommendBtn.disabled = false;
    }

    function handleCellClick(event) {
        const clickedCell = event.target;

        if (activeTile !== null && clickedCell.textContent === '') {
            clickedCell.textContent = activeTile.value === '*' ? '☆' : activeTile.value;
            clickedCell.classList.add('placed');

            drawnTileArea.innerHTML = '';

            placedCount++;
            activeTile = null;
            warning.textContent = "";
            removeRecommendationHighlight();

            if (placedCount < 20) {
                drawButton.disabled = false;
                recommendBtn.disabled = true;
            } else {
                 drawButton.disabled = true;
                 recommendBtn.disabled = true;
                setTimeout(endGame, 100);
            }

        } else if (activeTile === null) {
            warning.textContent = "타일을 먼저 '다음 타일 뽑기' 버튼으로 뽑아주세요.";
        } else if (clickedCell.textContent !== '') {
            warning.textContent = "이미 타일이 놓여있는 칸입니다.";
        }
    }

    function endGame() {
        warning.textContent = "보드가 다 채워졌습니다!";
        drawButton.disabled = true;
        recommendBtn.disabled = true;
        drawnTileArea.innerHTML = '';
        removeRecommendationHighlight();

        const jokerPlacedCell = Array.from(board.children).find(cell => cell.textContent === '☆');

        if (jokerPlacedCell) {
            jokerArea.style.display = 'block';
            jokerSelect.innerHTML = '';
            for (let i = 1; i <= 30; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                jokerSelect.appendChild(option);
            }
             jokerSelect.value = 15;
             warning.textContent = "조커 값을 선택해주세요.";
        } else {
            calculateScore();
        }
    }

    function confirmJoker() {
         const selectedValue = parseInt(jokerSelect.value, 10);
         const jokerPlacedCell = Array.from(board.children).find(cell => cell.textContent === '☆');

         if (jokerPlacedCell && !isNaN(selectedValue)) {
             jokerPlacedCell.textContent = selectedValue;
         } else {
             warning.textContent = "조커 값을 올바르게 선택해주세요.";
             return;
         }

         jokerArea.style.display = 'none';
         warning.textContent = "";

         calculateScore();
    }

    function calculateScore() {
        const boardValues = Array.from(board.children).map(cell => cell.textContent);
        let totalScore = getScoreFromBoard(boardValues);

        let breakdown = "점수 상세: ";
        let currentSequenceValues = [];
        let currentSequenceLength = 0;
        let lastValue = -Infinity;
        let tempBreakdownParts = [];

        for (let i = 0; i < boardValues.length; i++) {
            const cellValue = parseInt(boardValues[i], 10);

            if (isNaN(cellValue)) {
                if (currentSequenceLength > 1) {
                    const sequenceScore = scoreTable[currentSequenceLength] || 0;
                    tempBreakdownParts.push(`[${currentSequenceValues.join('→')}] ${currentSequenceLength}칸(${sequenceScore}점)`);
                }
                currentSequenceLength = 0;
                currentSequenceValues = [];
                lastValue = -Infinity;
                continue;
            }

            if (currentSequenceLength === 0 || cellValue >= lastValue) {
                currentSequenceLength++;
                currentSequenceValues.push(cellValue);
            } else {
                if (currentSequenceLength > 1) {
                    const sequenceScore = scoreTable[currentSequenceLength] || 0;
                    tempBreakdownParts.push(`[${currentSequenceValues.join('→')}] ${currentSequenceLength}칸(${sequenceScore}점)`);
                }
                currentSequenceLength = 1;
                currentSequenceValues = [cellValue];
            }
            lastValue = cellValue;
        }

        if (currentSequenceLength > 1) {
            const sequenceScore = scoreTable[currentSequenceLength] || 0;
            tempBreakdownParts.push(`[${currentSequenceValues.join('→')}] ${currentSequenceLength}칸(${sequenceScore}점)`);
        }

        breakdown += tempBreakdownParts.join(' + ');
        if (tempBreakdownParts.length === 0) {
            breakdown += "연속된 오름차순/같음 구간이 없습니다 (2칸 이상).";
        }

        document.getElementById('score').textContent = totalScore;
        scoreBreakdown.textContent = breakdown;
        submitBtn.disabled = false;
    }

    // --- 로컬 랭킹(localStorage) ---
    const RANKING_KEY = 'streams_rankings';

    function saveRanking(playerName, score) {
        let rankings = getRankings();
        const now = new Date();
        const newEntry = {
            name: playerName,
            score: score,
            date: now.toLocaleString('ko-KR', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit'
            })
        };

        rankings.push(newEntry);

        rankings.sort((a, b) => {
            if (a.score === b.score) {
                return new Date(a.date).getTime() - new Date(b.date).getTime();
            }
            return b.score - a.score;
        });

        rankings = rankings.slice(0, 10);

        localStorage.setItem(RANKING_KEY, JSON.stringify(rankings));
        displayRanking();
    }

    function getRankings() {
        const storedRankings = localStorage.getItem(RANKING_KEY);
        return storedRankings ? JSON.parse(storedRankings) : [];
    }

    function displayRanking() {
        const rankings = getRankings();
        rankingList.innerHTML = '';

        if (rankings.length === 0) {
            rankingList.innerHTML = '<li>아직 랭킹이 없습니다. 첫 점수를 기록해 보세요!</li>';
            return;
        }

        rankings.forEach((entry, index) => {
            const listItem = document.createElement('li');
            listItem.innerHTML = `
                <span class="rank-name">${index + 1}. ${entry.name}</span>
                <span>
                    <span class="rank-score">${entry.score}점</span>
                    <span class="rank-date">(${entry.date})</span>
                </span>
            `;
            rankingList.appendChild(listItem);
        });
    }

// 교체 시작: submitResult
async function submitResult() {
  const playerName = (document.getElementById('player')?.value || '').trim() || '익명';
  const finalScore = parseInt(document.getElementById('score')?.textContent || '0', 10) || 0;

  // 보드 상태 / 뽑은 순서
  const finalBoardState = Array.from(document.getElementById('board').children).map(cell => cell.textContent);
  const drawOrderState  = (typeof drawOrder !== 'undefined' && Array.isArray(drawOrder) ? drawOrder : [])
                            .map(v => v === '*' ? '☆' : v);

  // 표시용 날짜
  const nowStr = new Date().toLocaleString('ko-KR', {
    year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'
  });

  // 안내
  alert(`${playerName}님의 최종 점수는 ${finalScore}점입니다!\n(결과가 서버 랭킹/월별 랭킹에도 반영됩니다.)`);

  // 1) 로컬 랭킹 갱신(왼쪽 카드)
  saveRanking(playerName, finalScore);

  // 2) 서버(GAS)로 기록 저장 → 구글시트 반영
  try {
    if (typeof gasSave === 'function') {
      await gasSave({
        name:  playerName,
        score: finalScore,
        tiles: finalBoardState,
        order: drawOrderState,
        date:  nowStr
      
      });
      window.refreshLeaderboards && window.refreshLeaderboards();
    }
  } catch (e) {
    console.warn('GAS 저장 실패:', e);
  }

  // 3) 서버 랭킹/월별 랭킹 다시 불러오기
  try {
    if (typeof refreshRanking === 'function') {
      await refreshRanking();
      await refreshMonthly();   // ← 저장 직후 월별 재조회

    }
  } catch (e) {
    console.warn('랭킹 새로고침 실패:', e);
  }

  // (선택) 기존 로그 유지
  console.log('--- 스트림스 게임 결과 ---');
  console.log('플레이어:', playerName);
  console.log('최종 점수:', finalScore);
  console.log('뽑은 타일 순서:', drawOrderState.join(', '));
  console.log('최종 보드 상태:', finalBoardState.join(', '));
  console.log('------------------------');
 
 

}
// 교체 끝


    document.addEventListener('DOMContentLoaded', () => {
        renderRemainingTiles();
        renderBoard();
        drawButton.disabled = false;
        recommendBtn.disabled = true;
        submitBtn.disabled = true;
        displayRanking();
    });
  </script>
<script> 
    /* ---------- 로컬 랭킹 (폴백) ---------- */
    const RANKING_KEY='streams_rankings';
    function getRankings(){ const s=localStorage.getItem(RANKING_KEY); return s?JSON.parse(s):[]; }
    function saveRanking(name,score){
      let arr=getRankings();
      arr.push({name,score,date:new Date().toLocaleString('ko-KR',{year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit'})});
      arr.sort((a,b)=>(b.score===a.score)?(new Date(a.date)-new Date(b.date)):(b.score-a.score));
      arr=arr.slice(0,10); localStorage.setItem(RANKING_KEY, JSON.stringify(arr)); displayRanking();
    }
    function displayRanking(){
      const ul=rankingList; ul.innerHTML='';
      const arr=getRankings();
      if (!arr.length){ ul.innerHTML='<li>아직 랭킹이 없습니다.</li>'; return; }
      arr.forEach((e,i)=>{
        const li=document.createElement('li');
        li.innerHTML=`<span class="rank-name">${i+1}. ${e.name}</span><span><span class="rank-score">${e.score}점</span> <span class="rank-date">(${e.date})</span></span>`;
        ul.appendChild(li);
      });
    }

    /* ---------- GAS 저장 엔드포인트 ---------- */
    // 상단 어딘가에 있는 상수
    const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycby5ZtLBzXl8sD4daPTIlvR4mnq_DZM_z6HWQHrF48qnTwDI5URcvK_PpCg5mMq74RT8ww/exec';

    // 이 함수만 교체
    async function gasSave({name, score, tiles, order, date}) {
      const params = new URLSearchParams({
        action: 'save',
        name : String(name || '익명'),
        score: String(score || 0),
        tiles: Array.isArray(tiles) ? tiles.join(',') : String(tiles || ''),
        order: Array.isArray(order) ? order.join(',') : String(order || ''),
        date : String(date || '')
      });
      const res = await fetch(`${GAS_ENDPOINT}?${params.toString()}`, { method: 'GET' });

      // 여기서 반드시 응답 내용을 확인!
      const txt = await res.text();
      let data;
      try { data = JSON.parse(txt); } catch { data = { ok:false, raw:txt }; }

      if (!res.ok || !data || data.ok === false) {
        console.warn('GAS save error:', res.status, data);
        throw new Error(`GAS save failed: HTTP ${res.status} / ${JSON.stringify(data)}`);
      }
      return data; // {ok:true, msg:'saved', ...}
    }


    /* ---------- GViz 조회 (전체/월별) ---------- */
    const SHEET_ID   = '1jBL_ZHXPJUCCopdPm-SVjmQLDw_zoQHoO6K9vJ95CiI';
    const SHEET_NAME = '스트림스';
    async function gasFetchTop(){
      const url=`https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(SHEET_NAME)}&range=A2:D`;
      const res=await fetch(url,{method:'GET'}); if(!res.ok) throw new Error('HTTP '+res.status);
      const txt=await res.text(); const match=txt.match(/\{[\s\S]*\}/); if(!match) throw new Error('Failed to parse GViz JSON');
      const data=JSON.parse(match[0]);
      const rows=(data.table?.rows||[]).map(r=>({
        index:r.c?.[0]?.v ?? '',
        date:(r.c?.[1]?.f ?? r.c?.[1]?.v ?? ''),
        name:r.c?.[2]?.v ?? '익명',
        score:Number(r.c?.[3]?.v ?? 0)
      })).filter(r=>!Number.isNaN(r.score));
      rows.sort((a,b)=>(b.score===a.score)?String(a.date).localeCompare(String(b.date)):(b.score-a.score));
      return rows; // 전체 행 반환 (renderServerRanking에서 Top10만 씀)
    }

    function escapeHtml(s){ return String(s).replace(/[&<>\"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

    function renderServerRanking(rows){
      const ul=document.getElementById('rankingList'); if(!ul) return; ul.innerHTML='';
      if(!rows || !rows.length){ ul.innerHTML='<li>서버 랭킹이 없습니다.</li>'; return; }
      rows.slice(0,10).forEach((r,i)=>{
        const li=document.createElement('li');
        const d=r.date||r.saved_at||'';
        li.innerHTML=`<span class="rank-name">${i+1}. ${escapeHtml(r.name||'익명')}</span><span><span class="rank-score">${escapeHtml(r.score)}</span> <span class="rank-date">(${escapeHtml(d)})</span></span>`;
        const s=li.querySelector('.rank-score'); if(s && !/점$/.test(s.textContent)) s.textContent+= '점';
        ul.appendChild(li);
      });
    }

    function monthKeyFrom(dateStr){ const s=String(dateStr||''); const m=s.match(/^(\d{4})[-/.](\d{1,2})/); if(!m) return ''; return `${m[1]}-${String(m[2]).padStart(2,'0')}`; }
    function buildMonthOptions(rows){
      const sel=document.getElementById('monthSelect'); if(!sel) return;
      const keys=Array.from(new Set(rows.map(r=>monthKeyFrom(r.date||r.saved_at)).filter(Boolean)));
      keys.sort((a,b)=>b.localeCompare(a));
      sel.innerHTML='';
      const now=new Date(); const currentKey=`${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}`;
      keys.forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=k; sel.appendChild(o); });
      if (keys.includes(currentKey)) sel.value=currentKey; else if(keys.length) sel.value=keys[0];
    }
    function renderMonthlyRankingFor(monthKey, rows){
      const ul=document.getElementById('rankingListMonthly'); if(!ul) return; ul.innerHTML='';
      const monthly=rows.filter(r=>monthKeyFrom(r.date||r.saved_at)===monthKey);
      if(!monthly.length){ ul.innerHTML='<li>이 달의 랭킹이 없습니다.</li>'; return; }
      monthly.slice(0,10).forEach((r,i)=>{
        const li=document.createElement('li'); const d=r.date||r.saved_at||'';
        li.innerHTML=`<span class="rank-name">${i+1}. ${escapeHtml(r.name||'익명')}</span><span><span class="rank-score">${escapeHtml(r.score)}</span> <span class="rank-date">(${escapeHtml(d)})</span></span>`;
        const s=li.querySelector('.rank-score'); if(s && !/점$/.test(s.textContent)) s.textContent+='점';
        ul.appendChild(li);
      });
    }

    async function refreshRanking(){
      try{
        const data = await gasFetchTop();
        renderServerRanking(data); // 전체(역대)만 갱신
      }catch(e){
        console.warn('Server ranking unavailable, falling back to local ranking.', e);
        if (typeof displayRanking==='function') displayRanking();
      }
    }


    // 초기 렌더
    document.addEventListener('DOMContentLoaded', ()=>{
      renderRemainingTiles(); renderBoard(); drawButton.disabled=false; recommendBtn.disabled=true; submitBtn.disabled=true;
      displayRanking(); // 로컬 폴백 먼저
      refreshRanking(); // 서버 시도
    });
  </script>

<script>
/* ===== 월별 랭킹 전용 코드 (기존 코드와 독립) ===== */

/* 날짜 "YYYY-MM" 키 뽑기 */
function monthKeyFrom(dateStr){
  const s = String(dateStr || '');
  const m = s.match(/^(\d{4})[-/.](\d{1,2})/);
  if (!m) return '';
  return `${m[1]}-${String(m[2]).padStart(2,'0')}`;
}

/* GViz 전체 행 읽기: 기존 gasFetchTop은 상위 10개만이므로, 월별용으로 전체를 새로 읽습니다 */
async function gasFetchAllRows(){
  // 기존 GAS 블록에서 쓰는 상수 재사용 (이미 파일 하단에 선언되어 있음)
  // const SHEET_ID = '...'; const SHEET_NAME = '...';
  const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(SHEET_NAME)}&range=A2:D`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('HTTP ' + res.status);
  const txt = await res.text();
  const match = txt.match(/\{[\s\S]*\}/);
  if(!match) throw new Error('Failed to parse GViz JSON');
  const data = JSON.parse(match[0]);

  // A=index, B=saved_at, C=name, D=score
  const rows = (data.table?.rows || []).map(r => ({
    index : r.c?.[0]?.v ?? '',
    date  : (r.c?.[1]?.f ?? r.c?.[1]?.v ?? ''),
    name  : r.c?.[2]?.v ?? '익명',
    score : Number(r.c?.[3]?.v ?? 0)
  })).filter(r => !Number.isNaN(r.score));

  // 점수 내림차순, 동점시 날짜 오름차순
  rows.sort((a,b) => (b.score === a.score) ? String(a.date).localeCompare(String(b.date)) : b.score - a.score);
  return rows; // 전체 반환
}

/* 드롭다운 옵션 만들기 (이번 달 우선 선택) */
function buildMonthOptions(rows){
  const sel = document.getElementById('monthSelect');
  if (!sel) return;
  const keys = [...new Set(rows.map(r => monthKeyFrom(r.date)).filter(Boolean))].sort((a,b)=>b.localeCompare(a));
  sel.innerHTML = '';
  keys.forEach(k => {
    const opt = document.createElement('option');
    opt.value = k; opt.textContent = k; sel.appendChild(opt);
  });
  const now = new Date();
  const current = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}`;
  if (keys.includes(current)) sel.value = current;
  else if (keys.length) sel.value = keys[0];
}

/* 선택된 월의 Top10 렌더 */
function renderMonthlyRankingFor(monthKey, rows){
  const ul = document.getElementById('rankingListMonthly');
  if (!ul) return;
  ul.innerHTML = '';
  const monthly = rows.filter(r => monthKeyFrom(r.date) === monthKey).slice(0,10);
  if (!monthly.length){
    ul.innerHTML = '<li>이 달의 랭킹이 없습니다.</li>';
    return;
  }
  monthly.forEach((r,i) => {
    const li = document.createElement('li');
    const d = r.date || '';
    li.innerHTML = `
      <span class="rank-name">${i+1}. ${r.name}</span>
      <span><span class="rank-score">${r.score}점</span> <span class="rank-date">(${d})</span></span>`;
    ul.appendChild(li);
  });
}

/* 페이지 로드 시 월별 랭킹 초기화 (전체 랭킹 로직은 기존 코드 유지) */
document.addEventListener('DOMContentLoaded', async () => {
  try{
    const rows = await gasFetchAllRows();  // 전체 데이터
    buildMonthOptions(rows);
    const sel = document.getElementById('monthSelect');
    if (sel && sel.options && sel.options.length){
      renderMonthlyRankingFor(sel.value, rows);
      sel.onchange = () => renderMonthlyRankingFor(sel.value, rows);
    }
  }catch(e){
    console.warn('월별 랭킹 불러오기 실패:', e);
    const ul = document.getElementById('rankingListMonthly');
    if (ul) ul.innerHTML = '<li>월별 데이터 로딩 실패</li>';
  }
});
</script>
<script>
async function refreshMonthly(){
  try{
    const rows = await gasFetchAllRows(); // 전체 행
    buildMonthOptions(rows);
    const sel = document.getElementById('monthSelect');
    if (sel && sel.options && sel.options.length){
      renderMonthlyRankingFor(sel.value, rows);
      sel.onchange = () => renderMonthlyRankingFor(sel.value, rows);
    } else {
      const ul = document.getElementById('rankingListMonthly');
      if (ul) ul.innerHTML = '<li>월 데이터가 없습니다.</li>';
    }
  }catch(e){
    console.warn('월별 랭킹 불러오기 실패:', e);
    const ul = document.getElementById('rankingListMonthly');
    if (ul) ul.innerHTML = '<li>월별 데이터 로딩 실패</li>';
  }
}
document.addEventListener('DOMContentLoaded', () => { refreshMonthly(); });
</script>
<script>
/* ===== 단일 리더보드 모듈: 전체 Top10 + 월별 Top10 (충돌 방지용) ===== */
(function(){
  // 시트 정보 (필요 시 바꿔주세요)
  const SHEET_ID   = '1jBL_ZHXPJUCCopdPm-SVjmQLDw_zoQHoO6K9vJ95CiI';
  const SHEET_NAME = '스트림스';

  // DOM
  const overallUL = document.getElementById('rankingList');
  const monthUL   = document.getElementById('rankingListMonthly');
  const monthSel  = document.getElementById('monthSelect');

  if (!overallUL) return; // 카드가 없으면 종료

  // 유틸
  const mkey = s => {
    const m = String(s||'').match(/^(\d{4})[-/.](\d{1,2})/);
    return m ? `${m[1]}-${String(m[2]).padStart(2,'0')}` : '';
  };
  const html = (i, r) =>
    `<span class="rank-name">${i}. ${r.name||'익명'}</span>
     <span><span class="rank-score">${r.score}점</span> <span class="rank-date">(${r.date||''})</span></span>`;

  async function fetchAllRows(){
    const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(SHEET_NAME)}&range=A2:D`;
    const res = await fetch(url, {method:'GET'});
    if (!res.ok) throw new Error('HTTP '+res.status);
    const txt = await res.text();
    const m = txt.match(/\{[\s\S]*\}/);
    const data = JSON.parse(m[0]);
    const rows = (data.table?.rows||[]).map(r=>({
      index : r.c?.[0]?.v ?? '',
      date  : r.c?.[1]?.f ?? r.c?.[1]?.v ?? '',
      name  : r.c?.[2]?.v ?? '익명',
      score : Number(r.c?.[3]?.v ?? 0),
    })).filter(r=>!Number.isNaN(r.score));
    // 점수 내림차순, 동점시 날짜 오름
    rows.sort((a,b)=> (b.score===a.score) ? String(a.date).localeCompare(String(b.date)) : b.score-a.score);
    return rows;
  }

  function renderOverall(rows){
    if (!overallUL) return;
    overallUL.innerHTML = '';
    rows.slice(0,10).forEach((r, i)=>{
      const li = document.createElement('li');
      li.innerHTML = html(i+1, r);
      overallUL.appendChild(li);
    });
  }

  function buildMonthOptions(rows){
    if (!monthSel) return;
    const keys = [...new Set(rows.map(r=>mkey(r.date)).filter(Boolean))].sort((a,b)=>b.localeCompare(a));
    monthSel.innerHTML = '';
    keys.forEach(k=>{
      const o = document.createElement('option');
      o.value = k; o.textContent = k;
      monthSel.appendChild(o);
    });
    const now = new Date();
    const cur = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}`;
    monthSel.value = keys.includes(cur) ? cur : (keys[0]||'');
  }

  function renderMonthly(rows){
    if (!monthUL || !monthSel) return;
    monthUL.innerHTML = '';
    const target = monthSel.value;
    const list = rows.filter(r=>mkey(r.date)===target).slice(0,10);
    if (!list.length){ monthUL.innerHTML='<li>이 달의 랭킹이 없습니다.</li>'; return; }
    list.forEach((r,i)=>{
      const li = document.createElement('li');
      li.innerHTML = html(i+1, r);
      monthUL.appendChild(li);
    });
  }

  async function refreshAll(){
    try{
      const rows = await fetchAllRows();   // 항상 "전체 행"
      renderOverall(rows);                 // 전체 Top10
      if (monthSel && monthUL){
        buildMonthOptions(rows);           // 드롭다운
        renderMonthly(rows);               // 현재 선택 월 Top10
        monthSel.onchange = ()=> renderMonthly(rows);
      }
    } catch (e){
      console.warn('리더보드 갱신 실패:', e);
      if (overallUL && !overallUL.children.length)
        overallUL.innerHTML = '<li>서버 랭킹을 불러오지 못했습니다.</li>';
      if (monthUL && !monthUL.children.length)
        monthUL.innerHTML = '<li>월별 데이터를 불러오지 못했습니다.</li>';
    }
  }

  // 외부에서 저장 후 재호출할 수 있도록 노출
  window.refreshLeaderboards = refreshAll;

  // DOM 준비 후 한 번만 실행 (기존 중복 로직이 있어도 우리가 마지막에 덮어씀)
  document.addEventListener('DOMContentLoaded', ()=>{
    // 다른 스크립트보다 늦게 실행되도록 약간 지연
    setTimeout(refreshAll, 50);
  });
})();
</script>

</body>
</html>






