<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ìŠ¤íŠ¸ë¦¼ìŠ¤ ì›¹ì•± v12 - ë²„ë¦¬ëŠ” ì¹¸ ìµœì í™”</title>
  <style>
    body {
      background-color: white;
      color: black;
      font-family: sans-serif;
      text-align: center;
      overflow-x: auto;
      padding-bottom: 50px;
      margin: 0;
    }
    .container {
        width: fit-content;
        margin: 0 auto;
        padding: 20px;
    }
    h1, h3, p, table, button, #jokerArea {
         margin-left: auto;
         margin-right: auto;
         width: fit-content;
    }
    p:not(:has(label)) {
         text-align: left;
         max-width: 600px;
         margin-left: auto;
         margin-right: auto;
    }

    .tile-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 10px;
      margin-bottom: 10px;
      width: 250px;
      min-height: 48px;
      border: 1px dashed #eee;
      padding: 5px;
      box-sizing: border-box;
    }
    #drawnTileArea {
        min-height: 48px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 10px;
        margin-bottom: 10px;
        width: 250px;
        border: 1px dashed #ccc;
        box-sizing: border-box;
    }
    .board {
      display: flex;
      justify-content: flex-start;
      margin-top: 20px;
      margin-bottom: 20px;
      width: 880px;
      border: 1px solid #555;
      padding: 2px;
      box-sizing: border-box;
    }

    .tile, .cell {
      width: 40px;
      height: 40px;
      border: 1px solid black;
      margin: 2px;
      line-height: 40px;
      font-size: 16px;
      font-weight: bold;
      text-align: center;
      box-sizing: border-box;
      flex-shrink: 0;
    }
    .tile {
      background-color: white;
      cursor: default;
    }
    #drawnTileArea .tile {
         cursor: default;
         margin: 0;
    }

    .highlight {
      animation: glow 1s infinite alternate;
      border-color: blue;
    }
    .recommended {
        animation: recommended-glow 0.8s infinite alternate;
        border-color: green;
    }
    @keyframes recommended-glow {
        from { background-color: rgba(144, 238, 144, 0.3); }
        to { background-color: rgba(144, 238, 144, 0.8); }
    }

    .cell {
      background-color: #f0f0f0;
      cursor: pointer;
    }
    .board .cell:nth-child(1),
    .board .cell:nth-child(6),
    .board .cell:nth-child(11),
    .board .cell:nth-child(16) {
        background-color: #D0F0FF;
    }

    #player {
        font-size: 16px;
        padding: 5px;
        margin-bottom: 10px;
        display: inline-block;
        width: 150px;
        box-sizing: border-box;
    }
    p label {
        display: inline-block;
        margin-right: 5px;
    }
    p:has(label) {
        text-align: center;
        max-width: none;
    }

    #jokerSelect, #resetBtn, button {
      margin: 10px 5px;
      font-size: 16px;
      padding: 8px 15px;
      cursor: pointer;
    }
    #warning {
      color: red;
      font-weight: bold;
      min-height: 1.2em;
      margin-bottom: 10px;
    }
    table.score-table {
      margin: 20px auto;
      border-collapse: collapse;
      font-size: 14px;
      width: fit-content;
    }
    .shaded {
      background-color: #f2f2f2;
    }
    @keyframes glow {
      from { background-color: #fff; }
      to { background-color: #ddd; }
    }
    /* ë­í‚¹ ìŠ¤íƒ€ì¼ */
    #rankingArea {
        margin-top: 40px;
        border: 1px solid #ccc;
        padding: 20px;
        background-color: #f9f9f9;
        text-align: left;
        width: 300px;
        margin-left: auto;
        margin-right: auto;
    }
    #rankingArea h3 {
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    }
    #rankingList {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    #rankingList li {
        padding: 5px 0;
        border-bottom: 1px dashed #eee;
        display: flex;
        justify-content: space-between;
    }
    #rankingList li:last-child {
        border-bottom: none;
    }
    #rankingList .rank-name {
        font-weight: bold;
    }
    #rankingList .rank-score {
        color: #007bff;
    }
    #rankingList .rank-date {
        font-size: 0.8em;
        color: #777;
    }
  </style>
</head>
<body>
  <div class="container">
      <h1>ìŠ¤íŠ¸ë¦¼ìŠ¤ ì›¹ì•± v12</h1>
      <p>
        ìŠ¤íŠ¸ë¦¼ìŠ¤ ê²Œì„ì€ 40ê°œì˜ íƒ€ì¼ ì¤‘ 20ê°œë¥¼ ë½‘ì•„ì„œ ë³´ë“œì— ë°°ì¹˜í•˜ëŠ” ê²Œì„ì…ë‹ˆë‹¤.<br>
        íƒ€ì¼ì„ ì—°ì†í•˜ì—¬ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë°°ì¹˜í• ìˆ˜ë¡ ë†’ì€ ì ìˆ˜ë¥¼ ë°›ìŠµë‹ˆë‹¤.<br>
        ìˆ«ìê°€ ê°™ì€ íƒ€ì¼ì€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì¸ì •ë©ë‹ˆë‹¤.<br>
        íƒ€ì¼ì„ í•˜ë‚˜ ë½‘ìœ¼ë©´ ë°˜ë“œì‹œ 20ì¹¸ ë³´ë“œì— ë°°ì¹˜ë¥¼ í•´ì•¼ ë‹¤ìŒ íƒ€ì¼ì„ ë½‘ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>
        [ë‹¤ìŒ íƒ€ì¼ ë½‘ê¸°] ë²„íŠ¼ì„ ëˆŒëŸ¬ 1ê°œì”© ë¬´ì‘ìœ„ë¡œ íƒ€ì¼ì„ ë½‘ìŠµë‹ˆë‹¤.<br>
        ë½‘íŒ íƒ€ì¼ì€ ë°˜ì§ì´ë©° ê°•ì¡°ë˜ê³ , 20ì¹¸ ë³´ë“œ ì¤‘ ì›í•˜ëŠ” ë¹ˆ ìœ„ì¹˜ì— í´ë¦­í•˜ì—¬ ë°°ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>
        **[ì¶”ì²œ ë°›ê¸°] ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ í˜„ì¬ ë½‘íŒ íƒ€ì¼ì„ ì–´ë””ì— ë†“ì•„ì•¼ ê°€ì¥ ë†’ì€ ì ìˆ˜ë¥¼ ë°›ì„ì§€ ì¶”ì²œí•´ì¤ë‹ˆë‹¤.**<br>
        â˜†ì€ ì¡°ì»¤ì´ë©°, ë§ˆì§€ë§‰ì— 1~30ê¹Œì§€ì˜ ì›í•˜ëŠ” ìˆ«ìë¡œ ì§€ì •ë©ë‹ˆë‹¤.<br>
        20ì¹¸ ë³´ë“œë¥¼ ëª¨ë‘ ì±„ìš°ë©´ ì ìˆ˜ê°€ ê³„ì‚°ë©ë‹ˆë‹¤.
      </p>
      <h3>ğŸ§® ì˜¤ë¦„ì°¨ìˆœ ë°°ì¹˜ ì¹¸ ìˆ˜ë³„ ì ìˆ˜í‘œ</h3>
      <table class="score-table">
        <tr><td class="shaded">1ì¹¸</td><td>0ì </td><td class="shaded">2ì¹¸</td><td>1ì </td><td class="shaded">3ì¹¸</td><td>3ì </td><td class="shaded">4ì¹¸</td><td>5ì </td><td class="shaded">5ì¹¸</td><td>7ì </td></tr>
        <tr><td class="shaded">6ì¹¸</td><td>9ì </td><td class="shaded">7ì¹¸</td><td>11ì </td><td class="shaded">8ì¹¸</td><td>15ì </td><td class="shaded">9ì¹¸</td><td>20ì </td><td class="shaded">10ì¹¸</td><td>25ì </td></tr>
        <tr><td class="shaded">11ì¹¸</td><td>30ì </td><td>12ì¹¸</td><td>35ì </td><td class="shaded">13ì¹¸</td><td>40ì </td><td class="shaded">14ì¹¸</td><td>50ì </td><td class="shaded">15ì¹¸</td><td>60ì </td></tr>
        <tr><td class="shaded">16ì¹¸</td><td>70ì </td><td class="shaded">17ì¹¸</td><td>85ì </td><td class="shaded">18ì¹¸</td><td>100ì </td><td class="shaded">19ì¹¸</td><td>150ì </td><td class="shaded">20ì¹¸</td><td>300ì </td></tr>
      </table>

      <p><label for="player">ì´ë¦„:</label> <input type="text" id="player" /></p>

      <h3>ë‚¨ì€ íƒ€ì¼</h3>
      <div class="tile-container" id="tileContainer"></div>

      <h3>ë½‘ì€ íƒ€ì¼ (ë³´ë“œì— ë°°ì¹˜í•˜ì„¸ìš”)</h3>
      <div id="drawnTileArea"></div>

      <button onclick="drawNextTile()">ë‹¤ìŒ íƒ€ì¼ ë½‘ê¸°</button>
      <button onclick="recommendPlacement()" id="recommendBtn" disabled>ì¶”ì²œ ë°›ê¸°</button>
      <button onclick="location.reload()" id="resetBtn">ì²˜ìŒìœ¼ë¡œ</button>

      <div id="warning"></div>
      <h3>20ì¹¸ ë³´ë“œ</h3>
      <div class="board" id="board"></div>

      <div id="jokerArea" style="display:none;">
        <label for="jokerSelect">â˜†ë¥¼ ì–´ë–¤ ìˆ«ìë¡œ ê°„ì£¼í•˜ì‹œê² ìŠµë‹ˆê¹Œ? </label>
        <select id="jokerSelect"></select>
        <button onclick="confirmJoker()">í™•ì •</button>
      </div>

      <p id="scoreBreakdown"></p>
      <p>ì ìˆ˜: <span id="score">0</span></p>

      <button onclick="submitResult()" disabled id="submitBtn">ê²°ê³¼ ì €ì¥</button>

      <!-- ë­í‚¹ ì˜ì—­ -->
      <div id="rankingArea">
          <h3>ğŸ† ì—­ëŒ€ ìµœê³  ì ìˆ˜ ë­í‚¹ ğŸ†</h3>
          <ul id="rankingList">
              <!-- ë­í‚¹ í•­ëª©ë“¤ì´ ì—¬ê¸°ì— ë™ì ìœ¼ë¡œ ì¶”ê°€ë  ì˜ˆì • -->
          </ul>
      </div>
  </div>

  <script>
    const scoreTable = {
      1: 0, 2: 1, 3: 3, 4: 5, 5: 7, 6: 9, 7: 11, 8: 15, 9: 20, 10: 25,
      11: 30, 12: 35, 13: 40, 14: 50, 15: 60, 16: 70, 17: 85, 18: 100, 19: 150, 20: 300
    };

    let allTiles = [];
    for (let i = 1; i <= 30; i++) {
      const count = (i >= 11 && i <= 19) ? 2 : 1;
      for (let j = 0; j < count; j++) allTiles.push(i);
    }
    allTiles.push('*');

    const tileContainer = document.getElementById("tileContainer");
    const drawnTileArea = document.getElementById("drawnTileArea");
    const board = document.getElementById("board");
    const submitBtn = document.getElementById("submitBtn");
    const jokerArea = document.getElementById("jokerArea");
    const jokerSelect = document.getElementById("jokerSelect");
    const scoreBreakdown = document.getElementById("scoreBreakdown");
    const warning = document.getElementById("warning");
    const drawButton = document.querySelector('button');
    const recommendBtn = document.getElementById('recommendBtn');
    const rankingList = document.getElementById('rankingList');

    let remainingTiles = [...allTiles];
    let activeTile = null;
    let placedCount = 0;
    let drawOrder = [];
    let currentRecommendationElement = null;

    const idealCellRanges = [
        [1, 2],
        [3, 4],
        [5, 6],
        [7, 8],
        [9, 10],
        [11, 11],
        [12, 12],
        [13, 13],
        [14, 14],
        [15, 15],
        [16, 16],
        [17, 17],
        [18, 18],
        [19, 19],
        [20, 21],
        [22, 23],
        [24, 25],
        [26, 27],
        [28, 29],
        [30, 30]
    ];

    function renderBoard() {
        board.innerHTML = '';
        for (let i = 0; i < 20; i++) {
            const div = document.createElement("div");
            div.className = "cell";
            div.dataset.index = i;
            div.addEventListener('click', handleCellClick);
            board.appendChild(div);
        }
    }

    function renderRemainingTiles() {
        tileContainer.innerHTML = '';
        remainingTiles.forEach((num) => {
            const div = document.createElement("div");
            div.className = "tile";
            div.textContent = num === '*' ? 'â˜†' : num;
            tileContainer.appendChild(div);
        });
    }

    function getScoreFromBoard(boardElementsArray) {
        let currentScore = 0;
        let currentSequenceLength = 0;
        let lastValue = -Infinity;

        for (let i = 0; i < boardElementsArray.length; i++) {
            const cellValue = parseInt(boardElementsArray[i], 10);

            if (isNaN(cellValue)) {
                 if (currentSequenceLength > 1) {
                     currentScore += scoreTable[currentSequenceLength] || 0;
                 }
                 currentSequenceLength = 0;
                 lastValue = -Infinity;
                 continue;
            }

            if (currentSequenceLength === 0 || cellValue >= lastValue) {
                currentSequenceLength++;
            } else {
                if (currentSequenceLength > 1) {
                    currentScore += scoreTable[currentSequenceLength] || 0;
                }
                currentSequenceLength = 1;
            }
            lastValue = cellValue;
        }

        if (currentSequenceLength > 1) {
            currentScore += scoreTable[currentSequenceLength] || 0;
        }
        return currentScore;
    }

    function getIdealFitScore(placedValue, index) {
        const idealRange = idealCellRanges[index];
        if (!idealRange) return 0;

        const [minIdeal, maxIdeal] = idealRange;

        if (placedValue >= minIdeal && placedValue <= maxIdeal) {
            return 10000;
        } else {
            let distanceToRange = Math.min(Math.abs(placedValue - minIdeal), Math.abs(placedValue - maxIdeal));
            return Math.max(0, 1000 - distanceToRange * 100);
        }
    }

    // ë²„ë¦¬ëŠ” ì¹¸ì˜ ì „ëµì  ê°€ì¹˜ë¥¼ í‰ê°€í•˜ëŠ” í•¨ìˆ˜
    function evaluateDiscardPotential(tempBoardState, index, placedValue, originalBoardState) {
        let discardScore = 0;

        // 1. í˜„ì¬ ë†“ì€ ê³³ì˜ ì ìˆ˜ ë³€í™” (ìŒìˆ˜ë„ ê³ ë ¤)
        const currentOverallScore = getScoreFromBoard(originalBoardState);
        const simulatedOverallScore = getScoreFromBoard(tempBoardState);
        discardScore += simulatedOverallScore - currentOverallScore;

        // 2. ë²„ë¦¬ëŠ” íƒ€ì¼ì˜ ìœ„ì¹˜ ì í•©ì„±
        if (index === 0) discardScore += (placedValue <= 15) ? 1000 : 10;
        else if (index === 19) discardScore += (placedValue > 15) ? 1000 : 10;
        else discardScore += 10;

        // 3. ë¯¸ë˜ ì‹œí€€ìŠ¤ íŒŒê´´ ìµœì†Œí™”
        let originalSequenceCount = 0;
        let newSequenceCount = 0;

        let currentSequenceLength = 0;
        let lastValue = -Infinity;
        for (let i = 0; i < 20; i++) {
            const val = parseInt(originalBoardState[i], 10);
            if (isNaN(val)) {
                if (currentSequenceLength > 1) originalSequenceCount++;
                currentSequenceLength = 0;
                lastValue = -Infinity;
                continue;
            }
            if (val >= lastValue) currentSequenceLength++;
            else { if (currentSequenceLength > 1) originalSequenceCount++; currentSequenceLength = 1; }
            lastValue = val;
        }
        if (currentSequenceLength > 1) originalSequenceCount++;

        currentSequenceLength = 0;
        lastValue = -Infinity;
        for (let i = 0; i < 20; i++) {
            const val = parseInt(tempBoardState[i], 10);
            if (isNaN(val)) {
                if (currentSequenceLength > 1) newSequenceCount++;
                currentSequenceLength = 0;
                lastValue = -Infinity;
                continue;
            }
            if (val >= lastValue) currentSequenceLength++;
            else { if (currentSequenceLength > 1) newSequenceCount++; currentSequenceLength = 1; }
            lastValue = val;
        }
        if (currentSequenceLength > 1) newSequenceCount++;

        discardScore -= (originalSequenceCount - newSequenceCount) * 100;

        return discardScore;
    }

    function recommendPlacement() {
        if (activeTile === null) {
            warning.textContent = "ì¶”ì²œí•  íƒ€ì¼ì´ ì—†ìŠµë‹ˆë‹¤. 'ë‹¤ìŒ íƒ€ì¼ ë½‘ê¸°'ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”.";
            return;
        }

        if (activeTile.value === '*') {
            warning.textContent = "ì¡°ì»¤(â˜†)ëŠ” ë‹¤ì–‘í•œ ìˆ«ìê°€ ë  ìˆ˜ ìˆì–´ì„œ ìµœì ì˜ ìœ„ì¹˜ë¥¼ ì°¾ëŠ” ê³„ì‚°ì´ ë§¤ìš° ë³µì¡í•´ìš”. ì§ì ‘ ë°°ì¹˜í•˜ëŠ” ê²Œ ë” ì¢‹ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤!";
            return;
        }

        warning.textContent = "";
        removeRecommendationHighlight();

        let currentBoardState = Array.from(board.children).map(cell => cell.textContent);
        const initialOverallScore = getScoreFromBoard(currentBoardState);

        let viableCandidates = [];

        for (let i = 0; i < 20; i++) {
            if (currentBoardState[i] === '') {
                let tempBoardState = [...currentBoardState];
                tempBoardState[i] = activeTile.value;

                // 1. ì˜¤ë¦„ì°¨ìˆœ ê·œì¹™ ìœ ì§€ í™•ì¸
                let prevVal = (i > 0 && !isNaN(parseInt(currentBoardState[i-1]))) ? parseInt(currentBoardState[i-1]) : -Infinity;
                let nextVal = (i < 19 && !isNaN(parseInt(currentBoardState[i+1]))) ? parseInt(currentBoardState[i+1]) : Infinity;

                if (!(activeTile.value >= prevVal && activeTile.value <= nextVal)) {
                    continue;
                }

                // 2. ì ìˆ˜ ë³€í™” ê³„ì‚°
                let simulatedScore = getScoreFromBoard(tempBoardState);
                let scoreGain = simulatedScore - initialOverallScore;

                if (scoreGain < 0) {
                    continue;
                }

                // 3. ë‹´ë‹¹ ìˆ«ì ë²”ìœ„ ì í•©ì„± ê°€ì¤‘ì¹˜
                const idealFitScore = getIdealFitScore(activeTile.value, i);
                const finalEvaluationScore = (idealFitScore * 1000000000) + scoreGain;

                viableCandidates.push({
                    index: i,
                    scoreGain: scoreGain,
                    idealFitScore: idealFitScore,
                    finalEvaluationScore: finalEvaluationScore
                });
            }
        }

        let bestCandidate = null;
        let recommendationMessage = '';

        if (viableCandidates.length > 0) {
            bestCandidate = viableCandidates.reduce((prev, current) =>
                (prev.finalEvaluationScore > current.finalEvaluationScore ? prev : current)
            );

            let topCandidates = viableCandidates.filter(cand => cand.finalEvaluationScore === bestCandidate.finalEvaluationScore);

            if (topCandidates.length > 1) {
                topCandidates.sort((a, b) => b.scoreGain - a.scoreGain);
                let candidatesWithHighestScoreGain = topCandidates.filter(cand => cand.scoreGain === topCandidates[0].scoreGain);

                let bestGapCandidate = null;
                let maxGapWidth = -Infinity;

                for (const cand of candidatesWithHighestScoreGain) {
                    const i = cand.index;
                    const prevCellFilled = (i > 0 && currentBoardState[i-1] !== '');
                    const nextCellFilled = (i < 19 && currentBoardState[i+1] !== '');

                    if (prevCellFilled && nextCellFilled) {
                        let prevVal = parseInt(currentBoardState[i-1]);
                        let nextVal = parseInt(currentBoardState[i+1]);
                        const currentGapWidth = nextVal - prevVal;
                        if (currentGapWidth > maxGapWidth) {
                            maxGapWidth = currentGapWidth;
                            bestGapCandidate = cand;
                        }
                    }
                }

                if (bestGapCandidate) {
                    bestCandidate = bestGapCandidate;
                } else {
                    bestCandidate = candidatesWithHighestScoreGain.reduce((prev, current) =>
                        (prev.index > current.index ? prev : current)
                    );
                }
            }
            recommendationMessage = `í˜„ì¬ íƒ€ì¼ì„ ë†“ì„ ë§Œí•œ ê³³ì€ ${bestCandidate.index + 1}ë²ˆ ì¹¸(ì˜ˆìƒ ì ìˆ˜ ë³€í™”: ${bestCandidate.scoreGain > 0 ? '+' : ''}${bestCandidate.scoreGain}ì ) ì…ë‹ˆë‹¤!`;

        } else {
            // ì •ìƒ ë°°ì¹˜ ë¶ˆê°€ â†’ ë²„ë¦¬ëŠ” ì¹¸ ì „ëµ
            let discardCandidates = [];
            for (let i = 0; i < 20; i++) {
                if (currentBoardState[i] === '') {
                    let tempBoardState = [...currentBoardState];
                    tempBoardState[i] = activeTile.value;

                    let discardEvalScore = evaluateDiscardPotential(tempBoardState, i, activeTile.value, currentBoardState);

                    discardCandidates.push({
                        index: i,
                        evaluationScore: discardEvalScore
                    });
                }
            }

            if (discardCandidates.length > 0) {
                bestCandidate = discardCandidates.reduce((prev, current) => (prev.evaluationScore > current.evaluationScore ? prev : current));

                let tempBoardStateForMessage = [...currentBoardState];
                tempBoardStateForMessage[bestCandidate.index] = activeTile.value;

                let discardScoreGain = getScoreFromBoard(tempBoardStateForMessage) - initialOverallScore;

                let discardDetails = [];
                let isAscendingViolation = false;
                let prevValForDiscard = (bestCandidate.index > 0 && !isNaN(parseInt(currentBoardState[bestCandidate.index-1]))) ? parseInt(currentBoardState[bestCandidate.index-1]) : -Infinity;
                let nextValForDiscard = (bestCandidate.index < 19 && !isNaN(parseInt(currentBoardState[bestCandidate.index+1]))) ? parseInt(currentBoardState[bestCandidate.index+1]) : Infinity;

                if (!(activeTile.value >= prevValForDiscard && activeTile.value <= nextValForDiscard)) {
                    isAscendingViolation = true;
                    discardDetails.push("ì˜¤ë¦„ì°¨ìˆœ ê·œì¹™ ìœ„ë°˜");
                }
                if (discardScoreGain < 0) {
                    discardDetails.push(`ì ìˆ˜ ${discardScoreGain}ì  ê°ì†Œ`);
                }
                if (discardScoreGain >= 0 && !isAscendingViolation) {
                    discardDetails.push("ì´ ì¹¸ì€ ì ìˆ˜ ì†ì‹¤ ë° ì˜¤ë¦„ì°¨ìˆœ ìœ„ë°˜ì´ ì—†ìŠµë‹ˆë‹¤ (ë²„ë¦¬ê¸° ì•„ê¹Œìš´ ì¹¸).");
                }

                recommendationMessage = `ì •ìƒì ì¸ ë°°ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ${bestCandidate.index + 1}ë²ˆ ì¹¸ì— ë°°ì¹˜í•˜ì—¬ ë²„ë¦¬ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤. (ì„¸ë¶€: ${discardDetails.length > 0 ? discardDetails.join(', ') : 'ì „ëµì  ë²„ë¦¬ê¸°'})`;
                bestCandidate.scoreGain = discardScoreGain;

            } else {
                warning.textContent = "íƒ€ì¼ì„ ë°°ì¹˜í•  ìˆ˜ ìˆëŠ” ë¹ˆ ì¹¸ì´ ì—†ìŠµë‹ˆë‹¤. (ëª¨ë“  ì¹¸ì´ ì±„ì›Œì ¸ ìˆìŠµë‹ˆë‹¤)";
                return;
            }
        }

        if (bestCandidate) {
            highlightRecommendation(board.children[bestCandidate.index]);
            warning.textContent = recommendationMessage;
        } else {
            warning.textContent = "íƒ€ì¼ì„ ë°°ì¹˜í•  ìˆ˜ ìˆëŠ” ìµœì ì˜ ìœ„ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜)";
        }
    }

    function highlightRecommendation(element) {
        removeRecommendationHighlight();
        currentRecommendationElement = element;
        if (currentRecommendationElement) {
            currentRecommendationElement.classList.add('recommended');
        }
    }

    function removeRecommendationHighlight() {
        if (currentRecommendationElement) {
            currentRecommendationElement.classList.remove('recommended');
            currentRecommendationElement = null;
        }
    }

    function drawNextTile() {
      if (activeTile !== null) {
        warning.textContent = " ë½‘ì€ íƒ€ì¼ì„ ë¨¼ì € ë³´ë“œì— ë°°ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.";
        return;
      }
      if (placedCount >= 20) {
           warning.textContent = "ë³´ë“œê°€ ë‹¤ ì±„ì›Œì¡ŒìŠµë‹ˆë‹¤. ì ìˆ˜ ê³„ì‚°ì„ í™•ì¸í•˜ì„¸ìš”.";
           drawButton.disabled = true;
           return;
       }
      if (remainingTiles.length === 0 && placedCount < 20) {
           warning.textContent = "ì˜¤ë¥˜: ê²Œì„ ì§„í–‰ì— í•„ìš”í•œ íƒ€ì¼ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.";
           drawButton.disabled = true;
           return;
      }

      warning.textContent = "";
      removeRecommendationHighlight();

      const idxToDraw = Math.floor(Math.random() * remainingTiles.length);
      const drawnValue = remainingTiles[idxToDraw];

      // ê¸°ë¡: ë½‘ì€ ìˆœì„œ ì €ì¥
      if (Array.isArray(drawOrder)) { drawOrder.push(drawnValue); }

      const drawnTileElement = tileContainer.children[idxToDraw];
      if (!drawnTileElement) {
           console.error("Drawn tile element not found at index", idxToDraw, "Remaining:", remainingTiles);
           warning.textContent = "ì˜¤ë¥˜: ë½‘ì€ íƒ€ì¼ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
          return;
      }

      drawnTileArea.appendChild(drawnTileElement);
      drawnTileElement.classList.add('highlight');

      remainingTiles.splice(idxToDraw, 1);

      activeTile = { value: drawnValue };

      renderRemainingTiles();

      drawButton.disabled = true;
      recommendBtn.disabled = false;
    }

    function handleCellClick(event) {
        const clickedCell = event.target;

        if (activeTile !== null && clickedCell.textContent === '') {
            clickedCell.textContent = activeTile.value === '*' ? 'â˜†' : activeTile.value;
            clickedCell.classList.add('placed');

            drawnTileArea.innerHTML = '';

            placedCount++;
            activeTile = null;
            warning.textContent = "";
            removeRecommendationHighlight();

            if (placedCount < 20) {
                drawButton.disabled = false;
                recommendBtn.disabled = true;
            } else {
                 drawButton.disabled = true;
                 recommendBtn.disabled = true;
                setTimeout(endGame, 100);
            }

        } else if (activeTile === null) {
            warning.textContent = "íƒ€ì¼ì„ ë¨¼ì € 'ë‹¤ìŒ íƒ€ì¼ ë½‘ê¸°' ë²„íŠ¼ìœ¼ë¡œ ë½‘ì•„ì£¼ì„¸ìš”.";
        } else if (clickedCell.textContent !== '') {
            warning.textContent = "ì´ë¯¸ íƒ€ì¼ì´ ë†“ì—¬ìˆëŠ” ì¹¸ì…ë‹ˆë‹¤.";
        }
    }

    function endGame() {
        warning.textContent = "ë³´ë“œê°€ ë‹¤ ì±„ì›Œì¡ŒìŠµë‹ˆë‹¤!";
        drawButton.disabled = true;
        recommendBtn.disabled = true;
        drawnTileArea.innerHTML = '';
        removeRecommendationHighlight();

        const jokerPlacedCell = Array.from(board.children).find(cell => cell.textContent === 'â˜†');

        if (jokerPlacedCell) {
            jokerArea.style.display = 'block';
            jokerSelect.innerHTML = '';
            for (let i = 1; i <= 30; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                jokerSelect.appendChild(option);
            }
             jokerSelect.value = 15;
             warning.textContent = "ì¡°ì»¤ ê°’ì„ ì„ íƒí•´ì£¼ì„¸ìš”.";
        } else {
            calculateScore();
        }
    }

    function confirmJoker() {
         const selectedValue = parseInt(jokerSelect.value, 10);
         const jokerPlacedCell = Array.from(board.children).find(cell => cell.textContent === 'â˜†');

         if (jokerPlacedCell && !isNaN(selectedValue)) {
             jokerPlacedCell.textContent = selectedValue;
         } else {
             warning.textContent = "ì¡°ì»¤ ê°’ì„ ì˜¬ë°”ë¥´ê²Œ ì„ íƒí•´ì£¼ì„¸ìš”.";
             return;
         }

         jokerArea.style.display = 'none';
         warning.textContent = "";

         calculateScore();
    }

    function calculateScore() {
        const boardValues = Array.from(board.children).map(cell => cell.textContent);
        let totalScore = getScoreFromBoard(boardValues);

        let breakdown = "ì ìˆ˜ ìƒì„¸: ";
        let currentSequenceValues = [];
        let currentSequenceLength = 0;
        let lastValue = -Infinity;
        let tempBreakdownParts = [];

        for (let i = 0; i < boardValues.length; i++) {
            const cellValue = parseInt(boardValues[i], 10);

            if (isNaN(cellValue)) {
                if (currentSequenceLength > 1) {
                    const sequenceScore = scoreTable[currentSequenceLength] || 0;
                    tempBreakdownParts.push(`[${currentSequenceValues.join('â†’')}] ${currentSequenceLength}ì¹¸(${sequenceScore}ì )`);
                }
                currentSequenceLength = 0;
                currentSequenceValues = [];
                lastValue = -Infinity;
                continue;
            }

            if (currentSequenceLength === 0 || cellValue >= lastValue) {
                currentSequenceLength++;
                currentSequenceValues.push(cellValue);
            } else {
                if (currentSequenceLength > 1) {
                    const sequenceScore = scoreTable[currentSequenceLength] || 0;
                    tempBreakdownParts.push(`[${currentSequenceValues.join('â†’')}] ${currentSequenceLength}ì¹¸(${sequenceScore}ì )`);
                }
                currentSequenceLength = 1;
                currentSequenceValues = [cellValue];
            }
            lastValue = cellValue;
        }

        if (currentSequenceLength > 1) {
            const sequenceScore = scoreTable[currentSequenceLength] || 0;
            tempBreakdownParts.push(`[${currentSequenceValues.join('â†’')}] ${currentSequenceLength}ì¹¸(${sequenceScore}ì )`);
        }

        breakdown += tempBreakdownParts.join(' + ');
        if (tempBreakdownParts.length === 0) {
            breakdown += "ì—°ì†ëœ ì˜¤ë¦„ì°¨ìˆœ/ê°™ìŒ êµ¬ê°„ì´ ì—†ìŠµë‹ˆë‹¤ (2ì¹¸ ì´ìƒ).";
        }

        document.getElementById('score').textContent = totalScore;
        scoreBreakdown.textContent = breakdown;
        submitBtn.disabled = false;
    }

    // --- ë¡œì»¬ ë­í‚¹(localStorage) ---
    const RANKING_KEY = 'streams_rankings';

    function saveRanking(playerName, score) {
        let rankings = getRankings();
        const now = new Date();
        const newEntry = {
            name: playerName,
            score: score,
            date: now.toLocaleString('ko-KR', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit'
            })
        };

        rankings.push(newEntry);

        rankings.sort((a, b) => {
            if (a.score === b.score) {
                return new Date(a.date).getTime() - new Date(b.date).getTime();
            }
            return b.score - a.score;
        });

        rankings = rankings.slice(0, 10);

        localStorage.setItem(RANKING_KEY, JSON.stringify(rankings));
        displayRanking();
    }

    function getRankings() {
        const storedRankings = localStorage.getItem(RANKING_KEY);
        return storedRankings ? JSON.parse(storedRankings) : [];
    }

    function displayRanking() {
        const rankings = getRankings();
        rankingList.innerHTML = '';

        if (rankings.length === 0) {
            rankingList.innerHTML = '<li>ì•„ì§ ë­í‚¹ì´ ì—†ìŠµë‹ˆë‹¤. ì²« ì ìˆ˜ë¥¼ ê¸°ë¡í•´ ë³´ì„¸ìš”!</li>';
            return;
        }

        rankings.forEach((entry, index) => {
            const listItem = document.createElement('li');
            listItem.innerHTML = `
                <span class="rank-name">${index + 1}. ${entry.name}</span>
                <span>
                    <span class="rank-score">${entry.score}ì </span>
                    <span class="rank-date">(${entry.date})</span>
                </span>
            `;
            rankingList.appendChild(listItem);
        });
    }

    function submitResult() {
        const playerName = document.getElementById('player').value.trim() || "ìµëª…";
        const finalScore = parseInt(document.getElementById('score').textContent, 10);
        const finalBoardState = Array.from(board.children).map(cell => cell.textContent);
        const drawOrderState = drawOrder.map(val => val === '*' ? 'â˜†' : val);

        alert(`${playerName}ë‹˜ì˜ ìµœì¢… ì ìˆ˜ëŠ” ${finalScore}ì ì…ë‹ˆë‹¤!\n(ê²°ê³¼ê°€ ë¸Œë¼ìš°ì € ì½˜ì†” ë° ê°œì¸ ë­í‚¹ì— ê¸°ë¡ë©ë‹ˆë‹¤.)`);

        saveRanking(playerName, finalScore);

        console.log("--- ìŠ¤íŠ¸ë¦¼ìŠ¤ ê²Œì„ ê²°ê³¼ ---");
        console.log("í”Œë ˆì´ì–´:", playerName);
        console.log("ìµœì¢… ì ìˆ˜:", finalScore);
        console.log("ë½‘ì€ íƒ€ì¼ ìˆœì„œ:", drawOrderState.join(', '));
        console.log("ìµœì¢… ë³´ë“œ ìƒíƒœ:", finalBoardState.join(', '));
        console.log("------------------------");
    }

    document.addEventListener('DOMContentLoaded', () => {
        renderRemainingTiles();
        renderBoard();
        drawButton.disabled = false;
        recommendBtn.disabled = true;
        submitBtn.disabled = true;
        displayRanking();
    });
  </script>

  <!-- ====== ì—¬ê¸°ë¶€í„°: GAS ì—°ë™ ìŠ¤í¬ë¦½íŠ¸ ====== -->
  <script>
  /* ===== Google Apps Script (GAS) ê³µìœ  ë­í‚¹ ì—°ë™ =====
     ì‚¬ìš© ì „ ì•„ë˜ GAS_ENDPOINT ë¥¼ ë³¸ì¸ì˜ ì›¹ì•± URLë¡œ ë°”ê¾¸ì„¸ìš”.
     ì˜ˆ: const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbx.../exec';
  */
  const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbzu8RE7GqIQdZeRUG2cW2qe_FWomSjlOGqsLMEVi6369gw1xtqq2J6ZD5xPQKKaLubqLQ/exec';


  /* ì„œë²„ ì €ì¥ */
  async function gasSave({name, score, tiles, order, date}) {
    try {
      if (!GAS_ENDPOINT || GAS_ENDPOINT.includes('PUT_YOUR_GAS_WEBAPP_URL_HERE')) return;
      const params = new URLSearchParams({
        action: 'save',
        name: String(name || 'ìµëª…'),
        score: String(score || 0),
        tiles: Array.isArray(tiles) ? tiles.join(',') : String(tiles || ''),
        order: Array.isArray(order) ? order.join(',') : String(order || ''),
        date: String(date || '')
      });
      await fetch(`${GAS_ENDPOINT}?${params.toString()}`, { method: 'GET' });
    } catch (e) {
      console.warn('GAS save failed:', e);
    }
  }

  /* ì„œë²„ ì¡°íšŒ(JSON ë°°ì—´ ê¸°ëŒ€: [{name, score, saved_at|date}, ...]) */
  async function gasFetchTop() {
    if (!GAS_ENDPOINT || GAS_ENDPOINT.includes('PUT_YOUR_GAS_WEBAPP_URL_HERE')) {
      throw new Error('GAS endpoint not configured');
    }
    const url = `${GAS_ENDPOINT}?action=leaderboard`;
    const res = await fetch(url, { method: 'GET' });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    return await res.json();
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>\\"']/g, m => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'
    }[m]));
  }

  /* ì„œë²„ ë­í‚¹ ë Œë”ë§ */
  function renderServerRanking(rows){
    const ul = document.getElementById('rankingList');
    if (!ul) return;
    ul.innerHTML = '';
    if (!rows || !rows.length){
      ul.innerHTML = '<li>ì„œë²„ ë­í‚¹ì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ê¸°ë¡í•´ ë³´ì„¸ìš”!</li>';
      return;
    }
    rows.slice(0, 10).forEach((r, i) => {
      const li = document.createElement('li');
      const displayDate = r.date || r.saved_at || '';
      li.innerHTML = `
        <span class="rank-name">${i+1}. ${escapeHtml(r.name || 'ìµëª…')}</span>
        <span>
          <span class="rank-score">${escapeHtml(r.score)}</span>
          <span class="rank-date">(${escapeHtml(displayDate)})</span>
        </span>`;
      const scoreSpan = li.querySelector('.rank-score');
      if (scoreSpan && !/ì $/.test(scoreSpan.textContent)) {
        scoreSpan.textContent = scoreSpan.textContent + 'ì ';
      }
      ul.appendChild(li);
    });
  }

  /* ì„œë²„ ë­í‚¹ ê°±ì‹ : ì‹¤íŒ¨ ì‹œ localStorage í´ë°± */
  async function refreshRanking(){
    try {
      const data = await gasFetchTop();
      renderServerRanking(data);
    } catch (e) {
      console.warn('Server ranking unavailable, falling back to local ranking.', e);
      if (typeof displayRanking === 'function') displayRanking();
    }
  }

  /* submitResult íŒ¨ì¹˜: ê¸°ì¡´ ë™ì‘ + ì„œë²„ ì €ì¥ + ì„œë²„ ë­í‚¹ ìƒˆë¡œê³ ì¹¨ */
  (function(){
    if (typeof submitResult === 'function'){
      const origSubmit = submitResult;
      window.submitResult = function(){
        const playerName = (document.getElementById('player')?.value || '').trim() || 'ìµëª…';
        const finalScore = parseInt(document.getElementById('score')?.textContent || '0', 10) || 0;
        const boardEl = document.getElementById('board');
        const finalBoardState = boardEl ? Array.from(boardEl.children).map(c=>c.textContent) : [];
        const drawOrderState = (typeof drawOrder !== 'undefined' ? drawOrder : []).map(v => v === '*' ? 'â˜†' : v);
        const nowStr = new Date().toLocaleString('ko-KR', {year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'});

        // ê¸°ì¡´ ë¡œì»¬ ì €ì¥/ì•Œë¦¼ ë¨¼ì € ìˆ˜í–‰
        origSubmit();

        // ì„œë²„ ì €ì¥ í›„ ë­í‚¹ ìƒˆë¡œê³ ì¹¨
        gasSave({name: playerName, score: finalScore, tiles: finalBoardState, order: drawOrderState, date: nowStr})
          .then(()=> refreshRanking());
      };
    }
  })();

  /* í˜ì´ì§€ ë¡œë“œ ì‹œ ì„œë²„ ë­í‚¹ ì‹œë„ */
  document.addEventListener('DOMContentLoaded', () => {
    refreshRanking();
  });
  </script>
  <!-- ====== /GAS ì—°ë™ ìŠ¤í¬ë¦½íŠ¸ ====== -->

</body>
</html>



