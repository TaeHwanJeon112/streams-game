<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>스트림스 웹앱 v12 - 버리는 칸 최적화</title>
  <style>
    body {
      background-color: white;
      color: black;
      font-family: sans-serif;
      text-align: center;
      overflow-x: auto;
      padding-bottom: 50px;
      margin: 0;
    }
    .container {
        width: fit-content;
        margin: 0 auto;
        padding: 20px;
    }
    h1, h3, p, table, button, #jokerArea {
         margin-left: auto;
         margin-right: auto;
         width: fit-content;
    }
    p:not(:has(label)) {
         text-align: left;
         max-width: 600px;
         margin-left: auto;
         margin-right: auto;
    }

    .tile-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 10px;
      margin-bottom: 10px;
      width: 250px;
      min-height: 48px;
      border: 1px dashed #eee;
      padding: 5px;
      box-sizing: border-box;
    }
    #drawnTileArea {
        min-height: 48px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 10px;
        margin-bottom: 10px;
        width: 250px;
        border: 1px dashed #ccc;
        box-sizing: border-box;
    }
    .board {
      display: flex;
      justify-content: flex-start;
      margin-top: 20px;
      margin-bottom: 20px;
      width: 880px;
      border: 1px solid #555;
      padding: 2px;
      box-sizing: border-box;
    }

    .tile, .cell {
      width: 40px;
      height: 40px;
      border: 1px solid black;
      margin: 2px;
      line-height: 40px;
      font-size: 16px;
      font-weight: bold;
      text-align: center;
      box-sizing: border-box;
      flex-shrink: 0;
    }
    .tile {
      background-color: white;
      cursor: default;
    }
    #drawnTileArea .tile {
         cursor: default;
         margin: 0;
    }

    .highlight {
      animation: glow 1s infinite alternate;
      border-color: blue;
    }
    .recommended {
        animation: recommended-glow 0.8s infinite alternate;
        border-color: green;
    }
    @keyframes recommended-glow {
        from { background-color: rgba(144, 238, 144, 0.3); }
        to { background-color: rgba(144, 238, 144, 0.8); }
    }

    .cell {
      background-color: #f0f0f0;
      cursor: pointer;
    }
    .board .cell:nth-child(1),
    .board .cell:nth-child(6),
    .board .cell:nth-child(11),
    .board .cell:nth-child(16) {
        background-color: #D0F0FF;
    }

    #player {
        font-size: 16px;
        padding: 5px;
        margin-bottom: 10px;
        display: inline-block;
        width: 150px;
        box-sizing: border-box;
    }
    p label {
        display: inline-block;
        margin-right: 5px;
    }
    p:has(label) {
        text-align: center;
        max-width: none;
    }

    #jokerSelect, #resetBtn, button {
      margin: 10px 5px;
      font-size: 16px;
      padding: 8px 15px;
      cursor: pointer;
    }
    #warning {
      color: red;
      font-weight: bold;
      min-height: 1.2em;
      margin-bottom: 10px;
    }
    table.score-table {
      margin: 20px auto;
      border-collapse: collapse;
      font-size: 14px;
      width: fit-content;
    }
    .shaded {
      background-color: #f2f2f2;
    }
    @keyframes glow {
      from { background-color: #fff; }
      to { background-color: #ddd; }
    }
    /* 랭킹 스타일 */
    #rankingArea {
        margin-top: 40px;
        border: 1px solid #ccc;
        padding: 20px;
        background-color: #f9f9f9;
        text-align: left;
        width: 300px;
        margin-left: auto;
        margin-right: auto;
    }
    #rankingArea h3 {
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    }
    #rankingList {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    #rankingList li {
        padding: 5px 0;
        border-bottom: 1px dashed #eee;
        display: flex;
        justify-content: space-between;
    }
    #rankingList li:last-child {
        border-bottom: none;
    }
    #rankingList .rank-name {
        font-weight: bold;
    }
    #rankingList .rank-score {
        color: #007bff;
    }
    #rankingList .rank-date {
        font-size: 0.8em;
        color: #777;
    }
  </style>
</head>
<body>
  <div class="container">
      <h1>스트림스 웹앱 v12</h1>
      <p>
        스트림스 게임은 40개의 타일 중 20개를 뽑아서 보드에 배치하는 게임입니다.<br>
        타일을 연속하여 오름차순으로 배치할수록 높은 점수를 받습니다.<br>
        숫자가 같은 타일은 오름차순으로 인정됩니다.<br>
        타일을 하나 뽑으면 반드시 20칸 보드에 배치를 해야 다음 타일을 뽑을 수 있습니다.<br>
        [다음 타일 뽑기] 버튼을 눌러 1개씩 무작위로 타일을 뽑습니다.<br>
        뽑힌 타일은 반짝이며 강조되고, 20칸 보드 중 원하는 빈 위치에 클릭하여 배치할 수 있습니다.<br>
        **[추천 받기] 버튼을 누르면 현재 뽑힌 타일을 어디에 놓아야 가장 높은 점수를 받을지 추천해줍니다.**<br>
        ☆은 조커이며, 마지막에 1~30까지의 원하는 숫자로 지정됩니다.<br>
        20칸 보드를 모두 채우면 점수가 계산됩니다.
      </p>
      <h3>🧮 오름차순 배치 칸 수별 점수표</h3>
      <table class="score-table">
        <tr><td class="shaded">1칸</td><td>0점</td><td class="shaded">2칸</td><td>1점</td><td class="shaded">3칸</td><td>3점</td><td class="shaded">4칸</td><td>5점</td><td class="shaded">5칸</td><td>7점</td></tr>
        <tr><td class="shaded">6칸</td><td>9점</td><td class="shaded">7칸</td><td>11점</td><td class="shaded">8칸</td><td>15점</td><td class="shaded">9칸</td><td>20점</td><td class="shaded">10칸</td><td>25점</td></tr>
        <tr><td class="shaded">11칸</td><td>30점</td><td>12칸</td><td>35점</td><td class="shaded">13칸</td><td>40점</td><td class="shaded">14칸</td><td>50점</td><td class="shaded">15칸</td><td>60점</td></tr>
        <tr><td class="shaded">16칸</td><td>70점</td><td class="shaded">17칸</td><td>85점</td><td class="shaded">18칸</td><td>100점</td><td class="shaded">19칸</td><td>150점</td><td class="shaded">20칸</td><td>300점</td></tr>
      </table>

      <p><label for="player">이름:</label> <input type="text" id="player" /></p>

      <h3>남은 타일</h3>
      <div class="tile-container" id="tileContainer"></div>

      <h3>뽑은 타일 (보드에 배치하세요)</h3>
      <div id="drawnTileArea"></div>

      <button onclick="drawNextTile()">다음 타일 뽑기</button>
      <button onclick="recommendPlacement()" id="recommendBtn" disabled>추천 받기</button>
      <button onclick="location.reload()" id="resetBtn">처음으로</button>

      <div id="warning"></div>
      <h3>20칸 보드</h3>
      <div class="board" id="board"></div>

      <div id="jokerArea" style="display:none;">
        <label for="jokerSelect">☆를 어떤 숫자로 간주하시겠습니까? </label>
        <select id="jokerSelect"></select>
        <button onclick="confirmJoker()">확정</button>
      </div>

      <p id="scoreBreakdown"></p>
      <p>점수: <span id="score">0</span></p>

      <button onclick="submitResult()" disabled id="submitBtn">결과 저장</button>

      <!-- 랭킹 영역 -->
      <div id="rankingArea">
          <h3>🏆 역대 최고 점수 랭킹 🏆</h3>
          <ul id="rankingList">
              <!-- 랭킹 항목들이 여기에 동적으로 추가될 예정 -->
          </ul>
      </div>
  </div>

  <script>
    const scoreTable = {
      1: 0, 2: 1, 3: 3, 4: 5, 5: 7, 6: 9, 7: 11, 8: 15, 9: 20, 10: 25,
      11: 30, 12: 35, 13: 40, 14: 50, 15: 60, 16: 70, 17: 85, 18: 100, 19: 150, 20: 300
    };

    let allTiles = [];
    for (let i = 1; i <= 30; i++) {
      const count = (i >= 11 && i <= 19) ? 2 : 1;
      for (let j = 0; j < count; j++) allTiles.push(i);
    }
    allTiles.push('*');

    const tileContainer = document.getElementById("tileContainer");
    const drawnTileArea = document.getElementById("drawnTileArea");
    const board = document.getElementById("board");
    const submitBtn = document.getElementById("submitBtn");
    const jokerArea = document.getElementById("jokerArea");
    const jokerSelect = document.getElementById("jokerSelect");
    const scoreBreakdown = document.getElementById("scoreBreakdown");
    const warning = document.getElementById("warning");
    const drawButton = document.querySelector('button');
    const recommendBtn = document.getElementById('recommendBtn');
    const rankingList = document.getElementById('rankingList');

    let remainingTiles = [...allTiles];
    let activeTile = null;
    let placedCount = 0;
    let drawOrder = [];
    let currentRecommendationElement = null;

    const idealCellRanges = [
        [1, 2],
        [3, 4],
        [5, 6],
        [7, 8],
        [9, 10],
        [11, 11],
        [12, 12],
        [13, 13],
        [14, 14],
        [15, 15],
        [16, 16],
        [17, 17],
        [18, 18],
        [19, 19],
        [20, 21],
        [22, 23],
        [24, 25],
        [26, 27],
        [28, 29],
        [30, 30]
    ];

    function renderBoard() {
        board.innerHTML = '';
        for (let i = 0; i < 20; i++) {
            const div = document.createElement("div");
            div.className = "cell";
            div.dataset.index = i;
            div.addEventListener('click', handleCellClick);
            board.appendChild(div);
        }
    }

    function renderRemainingTiles() {
        tileContainer.innerHTML = '';
        remainingTiles.forEach((num) => {
            const div = document.createElement("div");
            div.className = "tile";
            div.textContent = num === '*' ? '☆' : num;
            tileContainer.appendChild(div);
        });
    }

    function getScoreFromBoard(boardElementsArray) {
        let currentScore = 0;
        let currentSequenceLength = 0;
        let lastValue = -Infinity;

        for (let i = 0; i < boardElementsArray.length; i++) {
            const cellValue = parseInt(boardElementsArray[i], 10);

            if (isNaN(cellValue)) {
                 if (currentSequenceLength > 1) {
                     currentScore += scoreTable[currentSequenceLength] || 0;
                 }
                 currentSequenceLength = 0;
                 lastValue = -Infinity;
                 continue;
            }

            if (currentSequenceLength === 0 || cellValue >= lastValue) {
                currentSequenceLength++;
            } else {
                if (currentSequenceLength > 1) {
                    currentScore += scoreTable[currentSequenceLength] || 0;
                }
                currentSequenceLength = 1;
            }
            lastValue = cellValue;
        }

        if (currentSequenceLength > 1) {
            currentScore += scoreTable[currentSequenceLength] || 0;
        }
        return currentScore;
    }

    function getIdealFitScore(placedValue, index) {
        const idealRange = idealCellRanges[index];
        if (!idealRange) return 0;

        const [minIdeal, maxIdeal] = idealRange;

        if (placedValue >= minIdeal && placedValue <= maxIdeal) {
            return 10000;
        } else {
            let distanceToRange = Math.min(Math.abs(placedValue - minIdeal), Math.abs(placedValue - maxIdeal));
            return Math.max(0, 1000 - distanceToRange * 100);
        }
    }

    // 버리는 칸의 전략적 가치를 평가하는 함수
    function evaluateDiscardPotential(tempBoardState, index, placedValue, originalBoardState) {
        let discardScore = 0;

        // 1. 현재 놓은 곳의 점수 변화 (음수도 고려)
        const currentOverallScore = getScoreFromBoard(originalBoardState);
        const simulatedOverallScore = getScoreFromBoard(tempBoardState);
        discardScore += simulatedOverallScore - currentOverallScore;

        // 2. 버리는 타일의 위치 적합성
        if (index === 0) discardScore += (placedValue <= 15) ? 1000 : 10;
        else if (index === 19) discardScore += (placedValue > 15) ? 1000 : 10;
        else discardScore += 10;

        // 3. 미래 시퀀스 파괴 최소화
        let originalSequenceCount = 0;
        let newSequenceCount = 0;

        let currentSequenceLength = 0;
        let lastValue = -Infinity;
        for (let i = 0; i < 20; i++) {
            const val = parseInt(originalBoardState[i], 10);
            if (isNaN(val)) {
                if (currentSequenceLength > 1) originalSequenceCount++;
                currentSequenceLength = 0;
                lastValue = -Infinity;
                continue;
            }
            if (val >= lastValue) currentSequenceLength++;
            else { if (currentSequenceLength > 1) originalSequenceCount++; currentSequenceLength = 1; }
            lastValue = val;
        }
        if (currentSequenceLength > 1) originalSequenceCount++;

        currentSequenceLength = 0;
        lastValue = -Infinity;
        for (let i = 0; i < 20; i++) {
            const val = parseInt(tempBoardState[i], 10);
            if (isNaN(val)) {
                if (currentSequenceLength > 1) newSequenceCount++;
                currentSequenceLength = 0;
                lastValue = -Infinity;
                continue;
            }
            if (val >= lastValue) currentSequenceLength++;
            else { if (currentSequenceLength > 1) newSequenceCount++; currentSequenceLength = 1; }
            lastValue = val;
        }
        if (currentSequenceLength > 1) newSequenceCount++;

        discardScore -= (originalSequenceCount - newSequenceCount) * 100;

        return discardScore;
    }

    function recommendPlacement() {
        if (activeTile === null) {
            warning.textContent = "추천할 타일이 없습니다. '다음 타일 뽑기'를 눌러주세요.";
            return;
        }

        if (activeTile.value === '*') {
            warning.textContent = "조커(☆)는 다양한 숫자가 될 수 있어서 최적의 위치를 찾는 계산이 매우 복잡해요. 직접 배치하는 게 더 좋을 수도 있습니다!";
            return;
        }

        warning.textContent = "";
        removeRecommendationHighlight();

        let currentBoardState = Array.from(board.children).map(cell => cell.textContent);
        const initialOverallScore = getScoreFromBoard(currentBoardState);

        let viableCandidates = [];

        for (let i = 0; i < 20; i++) {
            if (currentBoardState[i] === '') {
                let tempBoardState = [...currentBoardState];
                tempBoardState[i] = activeTile.value;

                // 1. 오름차순 규칙 유지 확인
                let prevVal = (i > 0 && !isNaN(parseInt(currentBoardState[i-1]))) ? parseInt(currentBoardState[i-1]) : -Infinity;
                let nextVal = (i < 19 && !isNaN(parseInt(currentBoardState[i+1]))) ? parseInt(currentBoardState[i+1]) : Infinity;

                if (!(activeTile.value >= prevVal && activeTile.value <= nextVal)) {
                    continue;
                }

                // 2. 점수 변화 계산
                let simulatedScore = getScoreFromBoard(tempBoardState);
                let scoreGain = simulatedScore - initialOverallScore;

                if (scoreGain < 0) {
                    continue;
                }

                // 3. 담당 숫자 범위 적합성 가중치
                const idealFitScore = getIdealFitScore(activeTile.value, i);
                const finalEvaluationScore = (idealFitScore * 1000000000) + scoreGain;

                viableCandidates.push({
                    index: i,
                    scoreGain: scoreGain,
                    idealFitScore: idealFitScore,
                    finalEvaluationScore: finalEvaluationScore
                });
            }
        }

        let bestCandidate = null;
        let recommendationMessage = '';

        if (viableCandidates.length > 0) {
            bestCandidate = viableCandidates.reduce((prev, current) =>
                (prev.finalEvaluationScore > current.finalEvaluationScore ? prev : current)
            );

            let topCandidates = viableCandidates.filter(cand => cand.finalEvaluationScore === bestCandidate.finalEvaluationScore);

            if (topCandidates.length > 1) {
                topCandidates.sort((a, b) => b.scoreGain - a.scoreGain);
                let candidatesWithHighestScoreGain = topCandidates.filter(cand => cand.scoreGain === topCandidates[0].scoreGain);

                let bestGapCandidate = null;
                let maxGapWidth = -Infinity;

                for (const cand of candidatesWithHighestScoreGain) {
                    const i = cand.index;
                    const prevCellFilled = (i > 0 && currentBoardState[i-1] !== '');
                    const nextCellFilled = (i < 19 && currentBoardState[i+1] !== '');

                    if (prevCellFilled && nextCellFilled) {
                        let prevVal = parseInt(currentBoardState[i-1]);
                        let nextVal = parseInt(currentBoardState[i+1]);
                        const currentGapWidth = nextVal - prevVal;
                        if (currentGapWidth > maxGapWidth) {
                            maxGapWidth = currentGapWidth;
                            bestGapCandidate = cand;
                        }
                    }
                }

                if (bestGapCandidate) {
                    bestCandidate = bestGapCandidate;
                } else {
                    bestCandidate = candidatesWithHighestScoreGain.reduce((prev, current) =>
                        (prev.index > current.index ? prev : current)
                    );
                }
            }
            recommendationMessage = `현재 타일을 놓을 만한 곳은 ${bestCandidate.index + 1}번 칸(예상 점수 변화: ${bestCandidate.scoreGain > 0 ? '+' : ''}${bestCandidate.scoreGain}점) 입니다!`;

        } else {
            // 정상 배치 불가 → 버리는 칸 전략
            let discardCandidates = [];
            for (let i = 0; i < 20; i++) {
                if (currentBoardState[i] === '') {
                    let tempBoardState = [...currentBoardState];
                    tempBoardState[i] = activeTile.value;

                    let discardEvalScore = evaluateDiscardPotential(tempBoardState, i, activeTile.value, currentBoardState);

                    discardCandidates.push({
                        index: i,
                        evaluationScore: discardEvalScore
                    });
                }
            }

            if (discardCandidates.length > 0) {
                bestCandidate = discardCandidates.reduce((prev, current) => (prev.evaluationScore > current.evaluationScore ? prev : current));

                let tempBoardStateForMessage = [...currentBoardState];
                tempBoardStateForMessage[bestCandidate.index] = activeTile.value;

                let discardScoreGain = getScoreFromBoard(tempBoardStateForMessage) - initialOverallScore;

                let discardDetails = [];
                let isAscendingViolation = false;
                let prevValForDiscard = (bestCandidate.index > 0 && !isNaN(parseInt(currentBoardState[bestCandidate.index-1]))) ? parseInt(currentBoardState[bestCandidate.index-1]) : -Infinity;
                let nextValForDiscard = (bestCandidate.index < 19 && !isNaN(parseInt(currentBoardState[bestCandidate.index+1]))) ? parseInt(currentBoardState[bestCandidate.index+1]) : Infinity;

                if (!(activeTile.value >= prevValForDiscard && activeTile.value <= nextValForDiscard)) {
                    isAscendingViolation = true;
                    discardDetails.push("오름차순 규칙 위반");
                }
                if (discardScoreGain < 0) {
                    discardDetails.push(`점수 ${discardScoreGain}점 감소`);
                }
                if (discardScoreGain >= 0 && !isAscendingViolation) {
                    discardDetails.push("이 칸은 점수 손실 및 오름차순 위반이 없습니다 (버리기 아까운 칸).");
                }

                recommendationMessage = `정상적인 배치를 찾을 수 없습니다. ${bestCandidate.index + 1}번 칸에 배치하여 버리는 것을 추천합니다. (세부: ${discardDetails.length > 0 ? discardDetails.join(', ') : '전략적 버리기'})`;
                bestCandidate.scoreGain = discardScoreGain;

            } else {
                warning.textContent = "타일을 배치할 수 있는 빈 칸이 없습니다. (모든 칸이 채워져 있습니다)";
                return;
            }
        }

        if (bestCandidate) {
            highlightRecommendation(board.children[bestCandidate.index]);
            warning.textContent = recommendationMessage;
        } else {
            warning.textContent = "타일을 배치할 수 있는 최적의 위치를 찾을 수 없습니다. (알 수 없는 오류)";
        }
    }

    function highlightRecommendation(element) {
        removeRecommendationHighlight();
        currentRecommendationElement = element;
        if (currentRecommendationElement) {
            currentRecommendationElement.classList.add('recommended');
        }
    }

    function removeRecommendationHighlight() {
        if (currentRecommendationElement) {
            currentRecommendationElement.classList.remove('recommended');
            currentRecommendationElement = null;
        }
    }

    function drawNextTile() {
      if (activeTile !== null) {
        warning.textContent = " 뽑은 타일을 먼저 보드에 배치해야 합니다.";
        return;
      }
      if (placedCount >= 20) {
           warning.textContent = "보드가 다 채워졌습니다. 점수 계산을 확인하세요.";
           drawButton.disabled = true;
           return;
       }
      if (remainingTiles.length === 0 && placedCount < 20) {
           warning.textContent = "오류: 게임 진행에 필요한 타일이 부족합니다.";
           drawButton.disabled = true;
           return;
      }

      warning.textContent = "";
      removeRecommendationHighlight();

      const idxToDraw = Math.floor(Math.random() * remainingTiles.length);
      const drawnValue = remainingTiles[idxToDraw];

      // 기록: 뽑은 순서 저장
      if (Array.isArray(drawOrder)) { drawOrder.push(drawnValue); }

      const drawnTileElement = tileContainer.children[idxToDraw];
      if (!drawnTileElement) {
           console.error("Drawn tile element not found at index", idxToDraw, "Remaining:", remainingTiles);
           warning.textContent = "오류: 뽑은 타일 요소를 찾을 수 없습니다.";
          return;
      }

      drawnTileArea.appendChild(drawnTileElement);
      drawnTileElement.classList.add('highlight');

      remainingTiles.splice(idxToDraw, 1);

      activeTile = { value: drawnValue };

      renderRemainingTiles();

      drawButton.disabled = true;
      recommendBtn.disabled = false;
    }

    function handleCellClick(event) {
        const clickedCell = event.target;

        if (activeTile !== null && clickedCell.textContent === '') {
            clickedCell.textContent = activeTile.value === '*' ? '☆' : activeTile.value;
            clickedCell.classList.add('placed');

            drawnTileArea.innerHTML = '';

            placedCount++;
            activeTile = null;
            warning.textContent = "";
            removeRecommendationHighlight();

            if (placedCount < 20) {
                drawButton.disabled = false;
                recommendBtn.disabled = true;
            } else {
                 drawButton.disabled = true;
                 recommendBtn.disabled = true;
                setTimeout(endGame, 100);
            }

        } else if (activeTile === null) {
            warning.textContent = "타일을 먼저 '다음 타일 뽑기' 버튼으로 뽑아주세요.";
        } else if (clickedCell.textContent !== '') {
            warning.textContent = "이미 타일이 놓여있는 칸입니다.";
        }
    }

    function endGame() {
        warning.textContent = "보드가 다 채워졌습니다!";
        drawButton.disabled = true;
        recommendBtn.disabled = true;
        drawnTileArea.innerHTML = '';
        removeRecommendationHighlight();

        const jokerPlacedCell = Array.from(board.children).find(cell => cell.textContent === '☆');

        if (jokerPlacedCell) {
            jokerArea.style.display = 'block';
            jokerSelect.innerHTML = '';
            for (let i = 1; i <= 30; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                jokerSelect.appendChild(option);
            }
             jokerSelect.value = 15;
             warning.textContent = "조커 값을 선택해주세요.";
        } else {
            calculateScore();
        }
    }

    function confirmJoker() {
         const selectedValue = parseInt(jokerSelect.value, 10);
         const jokerPlacedCell = Array.from(board.children).find(cell => cell.textContent === '☆');

         if (jokerPlacedCell && !isNaN(selectedValue)) {
             jokerPlacedCell.textContent = selectedValue;
         } else {
             warning.textContent = "조커 값을 올바르게 선택해주세요.";
             return;
         }

         jokerArea.style.display = 'none';
         warning.textContent = "";

         calculateScore();
    }

    function calculateScore() {
        const boardValues = Array.from(board.children).map(cell => cell.textContent);
        let totalScore = getScoreFromBoard(boardValues);

        let breakdown = "점수 상세: ";
        let currentSequenceValues = [];
        let currentSequenceLength = 0;
        let lastValue = -Infinity;
        let tempBreakdownParts = [];

        for (let i = 0; i < boardValues.length; i++) {
            const cellValue = parseInt(boardValues[i], 10);

            if (isNaN(cellValue)) {
                if (currentSequenceLength > 1) {
                    const sequenceScore = scoreTable[currentSequenceLength] || 0;
                    tempBreakdownParts.push(`[${currentSequenceValues.join('→')}] ${currentSequenceLength}칸(${sequenceScore}점)`);
                }
                currentSequenceLength = 0;
                currentSequenceValues = [];
                lastValue = -Infinity;
                continue;
            }

            if (currentSequenceLength === 0 || cellValue >= lastValue) {
                currentSequenceLength++;
                currentSequenceValues.push(cellValue);
            } else {
                if (currentSequenceLength > 1) {
                    const sequenceScore = scoreTable[currentSequenceLength] || 0;
                    tempBreakdownParts.push(`[${currentSequenceValues.join('→')}] ${currentSequenceLength}칸(${sequenceScore}점)`);
                }
                currentSequenceLength = 1;
                currentSequenceValues = [cellValue];
            }
            lastValue = cellValue;
        }

        if (currentSequenceLength > 1) {
            const sequenceScore = scoreTable[currentSequenceLength] || 0;
            tempBreakdownParts.push(`[${currentSequenceValues.join('→')}] ${currentSequenceLength}칸(${sequenceScore}점)`);
        }

        breakdown += tempBreakdownParts.join(' + ');
        if (tempBreakdownParts.length === 0) {
            breakdown += "연속된 오름차순/같음 구간이 없습니다 (2칸 이상).";
        }

        document.getElementById('score').textContent = totalScore;
        scoreBreakdown.textContent = breakdown;
        submitBtn.disabled = false;
    }

    // --- 로컬 랭킹(localStorage) ---
    const RANKING_KEY = 'streams_rankings';

    function saveRanking(playerName, score) {
        let rankings = getRankings();
        const now = new Date();
        const newEntry = {
            name: playerName,
            score: score,
            date: now.toLocaleString('ko-KR', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit'
            })
        };

        rankings.push(newEntry);

        rankings.sort((a, b) => {
            if (a.score === b.score) {
                return new Date(a.date).getTime() - new Date(b.date).getTime();
            }
            return b.score - a.score;
        });

        rankings = rankings.slice(0, 10);

        localStorage.setItem(RANKING_KEY, JSON.stringify(rankings));
        displayRanking();
    }

    function getRankings() {
        const storedRankings = localStorage.getItem(RANKING_KEY);
        return storedRankings ? JSON.parse(storedRankings) : [];
    }

    function displayRanking() {
        const rankings = getRankings();
        rankingList.innerHTML = '';

        if (rankings.length === 0) {
            rankingList.innerHTML = '<li>아직 랭킹이 없습니다. 첫 점수를 기록해 보세요!</li>';
            return;
        }

        rankings.forEach((entry, index) => {
            const listItem = document.createElement('li');
            listItem.innerHTML = `
                <span class="rank-name">${index + 1}. ${entry.name}</span>
                <span>
                    <span class="rank-score">${entry.score}점</span>
                    <span class="rank-date">(${entry.date})</span>
                </span>
            `;
            rankingList.appendChild(listItem);
        });
    }

    function submitResult() {
        const playerName = document.getElementById('player').value.trim() || "익명";
        const finalScore = parseInt(document.getElementById('score').textContent, 10);
        const finalBoardState = Array.from(board.children).map(cell => cell.textContent);
        const drawOrderState = drawOrder.map(val => val === '*' ? '☆' : val);

        alert(`${playerName}님의 최종 점수는 ${finalScore}점입니다!\n(결과가 브라우저 콘솔 및 개인 랭킹에 기록됩니다.)`);

        saveRanking(playerName, finalScore);

        console.log("--- 스트림스 게임 결과 ---");
        console.log("플레이어:", playerName);
        console.log("최종 점수:", finalScore);
        console.log("뽑은 타일 순서:", drawOrderState.join(', '));
        console.log("최종 보드 상태:", finalBoardState.join(', '));
        console.log("------------------------");
    }

    document.addEventListener('DOMContentLoaded', () => {
        renderRemainingTiles();
        renderBoard();
        drawButton.disabled = false;
        recommendBtn.disabled = true;
        submitBtn.disabled = true;
        displayRanking();
    });
  </script>

  <!-- ====== 여기부터: GAS 연동 스크립트 ====== -->
  <script>
  /* ===== Google Apps Script (GAS) 공유 랭킹 연동 =====
     사용 전 아래 GAS_ENDPOINT 를 본인의 웹앱 URL로 바꾸세요.
     예: const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbx.../exec';
  */
  const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbzu8RE7GqIQdZeRUG2cW2qe_FWomSjlOGqsLMEVi6369gw1xtqq2J6ZD5xPQKKaLubqLQ/exec';


  /* 서버 저장 */
  async function gasSave({name, score, tiles, order, date}) {
    try {
      if (!GAS_ENDPOINT || GAS_ENDPOINT.includes('PUT_YOUR_GAS_WEBAPP_URL_HERE')) return;
      const params = new URLSearchParams({
        action: 'save',
        name: String(name || '익명'),
        score: String(score || 0),
        tiles: Array.isArray(tiles) ? tiles.join(',') : String(tiles || ''),
        order: Array.isArray(order) ? order.join(',') : String(order || ''),
        date: String(date || '')
      });
      await fetch(`${GAS_ENDPOINT}?${params.toString()}`, { method: 'GET' });
    } catch (e) {
      console.warn('GAS save failed:', e);
    }
  }

  /* 서버 조회(JSON 배열 기대: [{name, score, saved_at|date}, ...]) */
  async function gasFetchTop() {
    if (!GAS_ENDPOINT || GAS_ENDPOINT.includes('PUT_YOUR_GAS_WEBAPP_URL_HERE')) {
      throw new Error('GAS endpoint not configured');
    }
    const url = `${GAS_ENDPOINT}?action=leaderboard`;
    const res = await fetch(url, { method: 'GET' });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    return await res.json();
  }

  function escapeHtml(s){
    return String(s).replace(/[&<>\\"']/g, m => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'
    }[m]));
  }

  /* 서버 랭킹 렌더링 */
  function renderServerRanking(rows){
    const ul = document.getElementById('rankingList');
    if (!ul) return;
    ul.innerHTML = '';
    if (!rows || !rows.length){
      ul.innerHTML = '<li>서버 랭킹이 없습니다. 먼저 기록해 보세요!</li>';
      return;
    }
    rows.slice(0, 10).forEach((r, i) => {
      const li = document.createElement('li');
      const displayDate = r.date || r.saved_at || '';
      li.innerHTML = `
        <span class="rank-name">${i+1}. ${escapeHtml(r.name || '익명')}</span>
        <span>
          <span class="rank-score">${escapeHtml(r.score)}</span>
          <span class="rank-date">(${escapeHtml(displayDate)})</span>
        </span>`;
      const scoreSpan = li.querySelector('.rank-score');
      if (scoreSpan && !/점$/.test(scoreSpan.textContent)) {
        scoreSpan.textContent = scoreSpan.textContent + '점';
      }
      ul.appendChild(li);
    });
  }

  /* 서버 랭킹 갱신: 실패 시 localStorage 폴백 */
  async function refreshRanking(){
    try {
      const data = await gasFetchTop();
      renderServerRanking(data);
    } catch (e) {
      console.warn('Server ranking unavailable, falling back to local ranking.', e);
      if (typeof displayRanking === 'function') displayRanking();
    }
  }

  /* submitResult 패치: 기존 동작 + 서버 저장 + 서버 랭킹 새로고침 */
  (function(){
    if (typeof submitResult === 'function'){
      const origSubmit = submitResult;
      window.submitResult = function(){
        const playerName = (document.getElementById('player')?.value || '').trim() || '익명';
        const finalScore = parseInt(document.getElementById('score')?.textContent || '0', 10) || 0;
        const boardEl = document.getElementById('board');
        const finalBoardState = boardEl ? Array.from(boardEl.children).map(c=>c.textContent) : [];
        const drawOrderState = (typeof drawOrder !== 'undefined' ? drawOrder : []).map(v => v === '*' ? '☆' : v);
        const nowStr = new Date().toLocaleString('ko-KR', {year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'});

        // 기존 로컬 저장/알림 먼저 수행
        origSubmit();

        // 서버 저장 후 랭킹 새로고침
        gasSave({name: playerName, score: finalScore, tiles: finalBoardState, order: drawOrderState, date: nowStr})
          .then(()=> refreshRanking());
      };
    }
  })();

  /* 페이지 로드 시 서버 랭킹 시도 */
  document.addEventListener('DOMContentLoaded', () => {
    refreshRanking();
  });
  </script>
  <!-- ====== /GAS 연동 스크립트 ====== -->

</body>
</html>



