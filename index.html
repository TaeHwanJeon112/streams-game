<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ìŠ¤íŠ¸ë¦¼ìŠ¤ ì›¹ì•± v15 ë­í‚¹ì‹œìŠ¤í…œ</title>
  <style>
    body {
      background-color: white;
      color: black;
      font-family: sans-serif;
      text-align: center;
      overflow-x: auto;
      padding-bottom: 50px;
      margin: 0;
    }
    .container {
        width: fit-content;
        margin: 0 auto;
        padding: 20px;
    }
    h1, h3, p, table, button, #jokerArea {
         margin-left: auto;
         margin-right: auto;
         width: fit-content;
    }
    p:not(:has(label)) {
         text-align: left;
         max-width: 600px;
         margin-left: auto;
         margin-right: auto;
    }

    .tile-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 10px;
      margin-bottom: 10px;
      width: 250px;
      min-height: 48px;
      border: 1px dashed #eee;
      padding: 5px;
      box-sizing: border-box;
    }
    #drawnTileArea {
        min-height: 48px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin-top: 10px;
        margin-bottom: 10px;
        width: 250px;
        border: 1px dashed #ccc;
        box-sizing: border-box;
    }
    .board {
      display: flex;
      justify-content: flex-start;
      margin-top: 20px;
      margin-bottom: 20px;
      width: 880px;
      border: 1px solid #555;
      padding: 2px;
      box-sizing: border-box;
    }

    .tile, .cell {
      width: 40px;
      height: 40px;
      border: 1px solid black;
      margin: 2px;
      line-height: 40px;
      font-size: 16px;
      font-weight: bold;
      text-align: center;
      box-sizing: border-box;
      flex-shrink: 0;
    }
    .tile {
      background-color: white;
      cursor: default;
    }
    #drawnTileArea .tile {
         cursor: default;
         margin: 0;
    }

    .highlight {
      animation: glow 1s infinite alternate;
      border-color: blue;
    }
    .recommended {
        animation: recommended-glow 0.8s infinite alternate;
        border-color: green;
    }
    @keyframes recommended-glow {
        from { background-color: rgba(144, 238, 144, 0.3); }
        to { background-color: rgba(144, 238, 144, 0.8); }
    }

    .cell {
      background-color: #f0f0f0;
      cursor: pointer;
    }
    .board .cell:nth-child(1),
    .board .cell:nth-child(6),
    .board .cell:nth-child(11),
    .board .cell:nth-child(16) {
        background-color: #D0F0FF;
    }

    #player {
        font-size: 16px;
        padding: 5px;
        margin-bottom: 10px;
        display: inline-block;
        width: 150px;
        box-sizing: border-box;
    }
    p label {
        display: inline-block;
        margin-right: 5px;
    }
    p:has(label) {
        text-align: center;
        max-width: none;
    }

    #jokerSelect, #resetBtn, button {
      margin: 10px 5px;
      font-size: 16px;
      padding: 8px 15px;
      cursor: pointer;
    }
    #warning {
      color: red;
      font-weight: bold;
      min-height: 1.2em;
      margin-bottom: 10px;
    }
    table.score-table {
      margin: 20px auto;
      border-collapse: collapse;
      font-size: 14px;
      width: fit-content;
    }
    .shaded {
      background-color: #f2f2f2;
    }
    @keyframes glow {
      from { background-color: #fff; }
      to { background-color: #ddd; }
    }
    /* ë­í‚¹ ìŠ¤íƒ€ì¼ */
    #rankingArea {
        margin-top: 40px;
        border: 1px solid #ccc;
        padding: 20px;
        background-color: #f9f9f9;
        text-align: left;
        width: 300px;
        margin-left: auto;
        margin-right: auto;
    }
    #rankingArea h3 {
        text-align: center;
        width: 100%;
        margin-bottom: 15px;
    }
    #rankingList {
        list-style: none;
        padding: 0;
        margin: 0;
    }
    #rankingList li {
        padding: 5px 0;
        border-bottom: 1px dashed #eee;
        display: flex;
        justify-content: space-between;
    }
    #rankingList li:last-child {
        border-bottom: none;
    }
    #rankingList .rank-name {
        font-weight: bold;
    }
    #rankingList .rank-score {
        color: #007bff;
    }
    #rankingList .rank-date {
        font-size: 0.8em;
        color: #777;
    }

    /* ì¤‘ì•™ ì •ë ¬ ë³´ì • */
   #tileContainer, #drawnTileArea, .board { 
    margin-left: auto; 
    margin-right: auto; 
    }
   #drawnTileArea { display:flex; justify-content:center; align-items:center; }
   body, .container { text-align: center; }

  .rankings-wrap{ display:flex; gap:16px; justify-content:center; align-items:flex-start; flex-wrap:wrap; max-width:660px; margin:20px auto; }
  .ranking-card{ width:300px; border:1px solid #ccc; background:#f9f9f9; padding:20px; text-align:left; }
  #rankingList, #rankingListMonthly{ list-style:none; padding:0; margin:0; }
  #rankingList li, #rankingListMonthly li{ padding:5px 0; border-bottom:1px dashed #eee; display:flex; justify-content:space-between; }
  #rankingList li:last-child, #rankingListMonthly li:last-child{ border-bottom:none; }
  .month-control{ margin-bottom:10px; text-align:center; }
  .month-control select{ padding:4px 8px; }


  </style>
</head>
<body>
  <div class="container">
      <h1>ìŠ¤íŠ¸ë¦¼ìŠ¤ ì›¹ì•± v15</h1>
      <p>
        ìŠ¤íŠ¸ë¦¼ìŠ¤ ê²Œì„ì€ 40ê°œì˜ íƒ€ì¼ ì¤‘ 20ê°œë¥¼ ë½‘ì•„ì„œ ë³´ë“œì— ë°°ì¹˜í•˜ëŠ” ê²Œì„ì…ë‹ˆë‹¤.<br>
        íƒ€ì¼ì„ ì—°ì†í•˜ì—¬ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ë°°ì¹˜í• ìˆ˜ë¡ ë†’ì€ ì ìˆ˜ë¥¼ ë°›ìŠµë‹ˆë‹¤.<br>
        ìˆ«ìê°€ ê°™ì€ íƒ€ì¼ì€ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì¸ì •ë©ë‹ˆë‹¤.<br>
        íƒ€ì¼ì„ í•˜ë‚˜ ë½‘ìœ¼ë©´ ë°˜ë“œì‹œ 20ì¹¸ ë³´ë“œì— ë°°ì¹˜ë¥¼ í•´ì•¼ ë‹¤ìŒ íƒ€ì¼ì„ ë½‘ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>
        [ë‹¤ìŒ íƒ€ì¼ ë½‘ê¸°] ë²„íŠ¼ì„ ëˆŒëŸ¬ 1ê°œì”© ë¬´ì‘ìœ„ë¡œ íƒ€ì¼ì„ ë½‘ìŠµë‹ˆë‹¤.<br>
        ë½‘íŒ íƒ€ì¼ì€ ë°˜ì§ì´ë©° ê°•ì¡°ë˜ê³ , 20ì¹¸ ë³´ë“œ ì¤‘ ì›í•˜ëŠ” ë¹ˆ ìœ„ì¹˜ì— í´ë¦­í•˜ì—¬ ë°°ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.<br>
        **[ì¶”ì²œ ë°›ê¸°] ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ í˜„ì¬ ë½‘íŒ íƒ€ì¼ì„ ì–´ë””ì— ë†“ì•„ì•¼ ê°€ì¥ ë†’ì€ ì ìˆ˜ë¥¼ ë°›ì„ì§€ ì¶”ì²œí•´ì¤ë‹ˆë‹¤.**<br>
        â˜†ì€ ì¡°ì»¤ì´ë©°, ë§ˆì§€ë§‰ì— 1~30ê¹Œì§€ì˜ ì›í•˜ëŠ” ìˆ«ìë¡œ ì§€ì •ë©ë‹ˆë‹¤.<br>
        20ì¹¸ ë³´ë“œë¥¼ ëª¨ë‘ ì±„ìš°ë©´ ì ìˆ˜ê°€ ê³„ì‚°ë©ë‹ˆë‹¤.
      </p>
      <h3>ğŸ§® ì˜¤ë¦„ì°¨ìˆœ ë°°ì¹˜ ì¹¸ ìˆ˜ë³„ ì ìˆ˜í‘œ</h3>
      <table class="score-table">
        <tr><td class="shaded">1ì¹¸</td><td>0ì </td><td class="shaded">2ì¹¸</td><td>1ì </td><td class="shaded">3ì¹¸</td><td>3ì </td><td class="shaded">4ì¹¸</td><td>5ì </td><td class="shaded">5ì¹¸</td><td>7ì </td></tr>
        <tr><td class="shaded">6ì¹¸</td><td>9ì </td><td class="shaded">7ì¹¸</td><td>11ì </td><td class="shaded">8ì¹¸</td><td>15ì </td><td class="shaded">9ì¹¸</td><td>20ì </td><td class="shaded">10ì¹¸</td><td>25ì </td></tr>
        <tr><td class="shaded">11ì¹¸</td><td>30ì </td><td>12ì¹¸</td><td>35ì </td><td class="shaded">13ì¹¸</td><td>40ì </td><td class="shaded">14ì¹¸</td><td>50ì </td><td class="shaded">15ì¹¸</td><td>60ì </td></tr>
        <tr><td class="shaded">16ì¹¸</td><td>70ì </td><td class="shaded">17ì¹¸</td><td>85ì </td><td class="shaded">18ì¹¸</td><td>100ì </td><td class="shaded">19ì¹¸</td><td>150ì </td><td class="shaded">20ì¹¸</td><td>300ì </td></tr>
      </table>

      <p><label for="player">ì´ë¦„:</label> <input type="text" id="player" /></p>

      <h3>ë‚¨ì€ íƒ€ì¼</h3>
      <div class="tile-container" id="tileContainer"></div>

      <h3>ë½‘ì€ íƒ€ì¼ (ë³´ë“œì— ë°°ì¹˜í•˜ì„¸ìš”)</h3>
      <div id="drawnTileArea"></div>

      <button onclick="drawNextTile()">ë‹¤ìŒ íƒ€ì¼ ë½‘ê¸°</button>
      <button onclick="recommendPlacement()" id="recommendBtn" disabled>ì¶”ì²œ ë°›ê¸°</button>
      <button onclick="location.reload()" id="resetBtn">ì²˜ìŒìœ¼ë¡œ</button>

      <div id="warning"></div>
      <h3>20ì¹¸ ë³´ë“œ</h3>
      <div class="board" id="board"></div>

      <div id="jokerArea" style="display:none;">
        <label for="jokerSelect">â˜†ë¥¼ ì–´ë–¤ ìˆ«ìë¡œ ê°„ì£¼í•˜ì‹œê² ìŠµë‹ˆê¹Œ? </label>
        <select id="jokerSelect"></select>
        <button onclick="confirmJoker()">í™•ì •</button>
      </div>

      <p id="scoreBreakdown"></p>
      <p>ì ìˆ˜: <span id="score">0</span></p>

      <button onclick="submitResult()" disabled id="submitBtn">ê²°ê³¼ ì €ì¥</button>

  <!-- ë­í‚¹ íŒ¨ë„: ì „ì²´ + ì›”ë³„ -->
 <div class="rankings-wrap">
   <div id="rankingArea" class="ranking-card">
    <h3>ğŸ† ì—­ëŒ€ ìµœê³  ì ìˆ˜ ë­í‚¹</h3>
    <ul id="rankingList"></ul>
   </div>

   <div id="rankingAreaMonthly" class="ranking-card">
     <h3>ğŸ“… ì›”ë³„ ë­í‚¹</h3>
     <div class="month-control">
       <label>ì›” ì„ íƒ: <select id="monthSelect"></select></label>
     </div>
     <ul id="rankingListMonthly"></ul>
   </div>
  </div>

  <script>
    const scoreTable = {
      1: 0, 2: 1, 3: 3, 4: 5, 5: 7, 6: 9, 7: 11, 8: 15, 9: 20, 10: 25,
      11: 30, 12: 35, 13: 40, 14: 50, 15: 60, 16: 70, 17: 85, 18: 100, 19: 150, 20: 300
    };

    let allTiles = [];
    for (let i = 1; i <= 30; i++) {
      const count = (i >= 11 && i <= 19) ? 2 : 1;
      for (let j = 0; j < count; j++) allTiles.push(i);
    }
    allTiles.push('*');

    const tileContainer = document.getElementById("tileContainer");
    const drawnTileArea = document.getElementById("drawnTileArea");
    const board = document.getElementById("board");
    const submitBtn = document.getElementById("submitBtn");
    const jokerArea = document.getElementById("jokerArea");
    const jokerSelect = document.getElementById("jokerSelect");
    const scoreBreakdown = document.getElementById("scoreBreakdown");
    const warning = document.getElementById("warning");
    const drawButton = document.querySelector('button');
    const recommendBtn = document.getElementById('recommendBtn');
    const rankingList = document.getElementById('rankingList');

    let remainingTiles = [...allTiles];
    let activeTile = null;
    let placedCount = 0;
    let drawOrder = [];
    let currentRecommendationElement = null;

    const idealCellRanges = [
        [1, 2],
        [3, 4],
        [5, 6],
        [7, 8],
        [9, 10],
        [11, 11],
        [12, 12],
        [13, 13],
        [14, 14],
        [15, 15],
        [16, 16],
        [17, 17],
        [18, 18],
        [19, 19],
        [20, 21],
        [22, 23],
        [24, 25],
        [26, 27],
        [28, 29],
        [30, 30]
    ];

    function renderBoard() {
        board.innerHTML = '';
        for (let i = 0; i < 20; i++) {
            const div = document.createElement("div");
            div.className = "cell";
            div.dataset.index = i;
            div.addEventListener('click', handleCellClick);
            board.appendChild(div);
        }
    }

    function renderRemainingTiles() {
        tileContainer.innerHTML = '';
        remainingTiles.forEach((num) => {
            const div = document.createElement("div");
            div.className = "tile";
            div.textContent = num === '*' ? 'â˜†' : num;
            tileContainer.appendChild(div);
        });
    }

    function getScoreFromBoard(boardElementsArray) {
        let currentScore = 0;
        let currentSequenceLength = 0;
        let lastValue = -Infinity;

        for (let i = 0; i < boardElementsArray.length; i++) {
            const cellValue = parseInt(boardElementsArray[i], 10);

            if (isNaN(cellValue)) {
                 if (currentSequenceLength > 1) {
                     currentScore += scoreTable[currentSequenceLength] || 0;
                 }
                 currentSequenceLength = 0;
                 lastValue = -Infinity;
                 continue;
            }

            if (currentSequenceLength === 0 || cellValue >= lastValue) {
                currentSequenceLength++;
            } else {
                if (currentSequenceLength > 1) {
                    currentScore += scoreTable[currentSequenceLength] || 0;
                }
                currentSequenceLength = 1;
            }
            lastValue = cellValue;
        }

        if (currentSequenceLength > 1) {
            currentScore += scoreTable[currentSequenceLength] || 0;
        }
        return currentScore;
    }

    function getIdealFitScore(placedValue, index) {
        const idealRange = idealCellRanges[index];
        if (!idealRange) return 0;

        const [minIdeal, maxIdeal] = idealRange;

        if (placedValue >= minIdeal && placedValue <= maxIdeal) {
            return 10000;
        } else {
            let distanceToRange = Math.min(Math.abs(placedValue - minIdeal), Math.abs(placedValue - maxIdeal));
            return Math.max(0, 1000 - distanceToRange * 100);
        }
    }

    // ë²„ë¦¬ëŠ” ì¹¸ì˜ ì „ëµì  ê°€ì¹˜ë¥¼ í‰ê°€í•˜ëŠ” í•¨ìˆ˜
    function evaluateDiscardPotential(tempBoardState, index, placedValue, originalBoardState) {
        let discardScore = 0;

        // 1. í˜„ì¬ ë†“ì€ ê³³ì˜ ì ìˆ˜ ë³€í™” (ìŒìˆ˜ë„ ê³ ë ¤)
        const currentOverallScore = getScoreFromBoard(originalBoardState);
        const simulatedOverallScore = getScoreFromBoard(tempBoardState);
        discardScore += simulatedOverallScore - currentOverallScore;

        // 2. ë²„ë¦¬ëŠ” íƒ€ì¼ì˜ ìœ„ì¹˜ ì í•©ì„±
        if (index === 0) discardScore += (placedValue <= 15) ? 1000 : 10;
        else if (index === 19) discardScore += (placedValue > 15) ? 1000 : 10;
        else discardScore += 10;

        // 3. ë¯¸ë˜ ì‹œí€€ìŠ¤ íŒŒê´´ ìµœì†Œí™”
        let originalSequenceCount = 0;
        let newSequenceCount = 0;

        let currentSequenceLength = 0;
        let lastValue = -Infinity;
        for (let i = 0; i < 20; i++) {
            const val = parseInt(originalBoardState[i], 10);
            if (isNaN(val)) {
                if (currentSequenceLength > 1) originalSequenceCount++;
                currentSequenceLength = 0;
                lastValue = -Infinity;
                continue;
            }
            if (val >= lastValue) currentSequenceLength++;
            else { if (currentSequenceLength > 1) originalSequenceCount++; currentSequenceLength = 1; }
            lastValue = val;
        }
        if (currentSequenceLength > 1) originalSequenceCount++;

        currentSequenceLength = 0;
        lastValue = -Infinity;
        for (let i = 0; i < 20; i++) {
            const val = parseInt(tempBoardState[i], 10);
            if (isNaN(val)) {
                if (currentSequenceLength > 1) newSequenceCount++;
                currentSequenceLength = 0;
                lastValue = -Infinity;
                continue;
            }
            if (val >= lastValue) currentSequenceLength++;
            else { if (currentSequenceLength > 1) newSequenceCount++; currentSequenceLength = 1; }
            lastValue = val;
        }
        if (currentSequenceLength > 1) newSequenceCount++;

        discardScore -= (originalSequenceCount - newSequenceCount) * 100;

        return discardScore;
    }

    function recommendPlacement() {
        if (activeTile === null) {
            warning.textContent = "ì¶”ì²œí•  íƒ€ì¼ì´ ì—†ìŠµë‹ˆë‹¤. 'ë‹¤ìŒ íƒ€ì¼ ë½‘ê¸°'ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”.";
            return;
        }

        if (activeTile.value === '*') {
            warning.textContent = "ì¡°ì»¤(â˜†)ëŠ” ë‹¤ì–‘í•œ ìˆ«ìê°€ ë  ìˆ˜ ìˆì–´ì„œ ìµœì ì˜ ìœ„ì¹˜ë¥¼ ì°¾ëŠ” ê³„ì‚°ì´ ë§¤ìš° ë³µì¡í•´ìš”. ì§ì ‘ ë°°ì¹˜í•˜ëŠ” ê²Œ ë” ì¢‹ì„ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤!";
            return;
        }

        warning.textContent = "";
        removeRecommendationHighlight();

        let currentBoardState = Array.from(board.children).map(cell => cell.textContent);
        const initialOverallScore = getScoreFromBoard(currentBoardState);

        let viableCandidates = [];

        for (let i = 0; i < 20; i++) {
            if (currentBoardState[i] === '') {
                let tempBoardState = [...currentBoardState];
                tempBoardState[i] = activeTile.value;

                // 1. ì˜¤ë¦„ì°¨ìˆœ ê·œì¹™ ìœ ì§€ í™•ì¸
                let prevVal = (i > 0 && !isNaN(parseInt(currentBoardState[i-1]))) ? parseInt(currentBoardState[i-1]) : -Infinity;
                let nextVal = (i < 19 && !isNaN(parseInt(currentBoardState[i+1]))) ? parseInt(currentBoardState[i+1]) : Infinity;

                if (!(activeTile.value >= prevVal && activeTile.value <= nextVal)) {
                    continue;
                }

                // 2. ì ìˆ˜ ë³€í™” ê³„ì‚°
                let simulatedScore = getScoreFromBoard(tempBoardState);
                let scoreGain = simulatedScore - initialOverallScore;

                if (scoreGain < 0) {
                    continue;
                }

                // 3. ë‹´ë‹¹ ìˆ«ì ë²”ìœ„ ì í•©ì„± ê°€ì¤‘ì¹˜
                const idealFitScore = getIdealFitScore(activeTile.value, i);
                const finalEvaluationScore = (idealFitScore * 1000000000) + scoreGain;

                viableCandidates.push({
                    index: i,
                    scoreGain: scoreGain,
                    idealFitScore: idealFitScore,
                    finalEvaluationScore: finalEvaluationScore
                });
            }
        }

        let bestCandidate = null;
        let recommendationMessage = '';

        if (viableCandidates.length > 0) {
            bestCandidate = viableCandidates.reduce((prev, current) =>
                (prev.finalEvaluationScore > current.finalEvaluationScore ? prev : current)
            );

            let topCandidates = viableCandidates.filter(cand => cand.finalEvaluationScore === bestCandidate.finalEvaluationScore);

            if (topCandidates.length > 1) {
                topCandidates.sort((a, b) => b.scoreGain - a.scoreGain);
                let candidatesWithHighestScoreGain = topCandidates.filter(cand => cand.scoreGain === topCandidates[0].scoreGain);

                let bestGapCandidate = null;
                let maxGapWidth = -Infinity;

                for (const cand of candidatesWithHighestScoreGain) {
                    const i = cand.index;
                    const prevCellFilled = (i > 0 && currentBoardState[i-1] !== '');
                    const nextCellFilled = (i < 19 && currentBoardState[i+1] !== '');

                    if (prevCellFilled && nextCellFilled) {
                        let prevVal = parseInt(currentBoardState[i-1]);
                        let nextVal = parseInt(currentBoardState[i+1]);
                        const currentGapWidth = nextVal - prevVal;
                        if (currentGapWidth > maxGapWidth) {
                            maxGapWidth = currentGapWidth;
                            bestGapCandidate = cand;
                        }
                    }
                }

                if (bestGapCandidate) {
                    bestCandidate = bestGapCandidate;
                } else {
                    bestCandidate = candidatesWithHighestScoreGain.reduce((prev, current) =>
                        (prev.index > current.index ? prev : current)
                    );
                }
            }
            recommendationMessage = `í˜„ì¬ íƒ€ì¼ì„ ë†“ì„ ë§Œí•œ ê³³ì€ ${bestCandidate.index + 1}ë²ˆ ì¹¸(ì˜ˆìƒ ì ìˆ˜ ë³€í™”: ${bestCandidate.scoreGain > 0 ? '+' : ''}${bestCandidate.scoreGain}ì ) ì…ë‹ˆë‹¤!`;

        } else {
            // ì •ìƒ ë°°ì¹˜ ë¶ˆê°€ â†’ ë²„ë¦¬ëŠ” ì¹¸ ì „ëµ
            let discardCandidates = [];
            for (let i = 0; i < 20; i++) {
                if (currentBoardState[i] === '') {
                    let tempBoardState = [...currentBoardState];
                    tempBoardState[i] = activeTile.value;

                    let discardEvalScore = evaluateDiscardPotential(tempBoardState, i, activeTile.value, currentBoardState);

                    discardCandidates.push({
                        index: i,
                        evaluationScore: discardEvalScore
                    });
                }
            }

            if (discardCandidates.length > 0) {
                bestCandidate = discardCandidates.reduce((prev, current) => (prev.evaluationScore > current.evaluationScore ? prev : current));

                let tempBoardStateForMessage = [...currentBoardState];
                tempBoardStateForMessage[bestCandidate.index] = activeTile.value;

                let discardScoreGain = getScoreFromBoard(tempBoardStateForMessage) - initialOverallScore;

                let discardDetails = [];
                let isAscendingViolation = false;
                let prevValForDiscard = (bestCandidate.index > 0 && !isNaN(parseInt(currentBoardState[bestCandidate.index-1]))) ? parseInt(currentBoardState[bestCandidate.index-1]) : -Infinity;
                let nextValForDiscard = (bestCandidate.index < 19 && !isNaN(parseInt(currentBoardState[bestCandidate.index+1]))) ? parseInt(currentBoardState[bestCandidate.index+1]) : Infinity;

                if (!(activeTile.value >= prevValForDiscard && activeTile.value <= nextValForDiscard)) {
                    isAscendingViolation = true;
                    discardDetails.push("ì˜¤ë¦„ì°¨ìˆœ ê·œì¹™ ìœ„ë°˜");
                }
                if (discardScoreGain < 0) {
                    discardDetails.push(`ì ìˆ˜ ${discardScoreGain}ì  ê°ì†Œ`);
                }
                if (discardScoreGain >= 0 && !isAscendingViolation) {
                    discardDetails.push("ì´ ì¹¸ì€ ì ìˆ˜ ì†ì‹¤ ë° ì˜¤ë¦„ì°¨ìˆœ ìœ„ë°˜ì´ ì—†ìŠµë‹ˆë‹¤ (ë²„ë¦¬ê¸° ì•„ê¹Œìš´ ì¹¸).");
                }

                recommendationMessage = `ì •ìƒì ì¸ ë°°ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ${bestCandidate.index + 1}ë²ˆ ì¹¸ì— ë°°ì¹˜í•˜ì—¬ ë²„ë¦¬ëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤. (ì„¸ë¶€: ${discardDetails.length > 0 ? discardDetails.join(', ') : 'ì „ëµì  ë²„ë¦¬ê¸°'})`;
                bestCandidate.scoreGain = discardScoreGain;

            } else {
                warning.textContent = "íƒ€ì¼ì„ ë°°ì¹˜í•  ìˆ˜ ìˆëŠ” ë¹ˆ ì¹¸ì´ ì—†ìŠµë‹ˆë‹¤. (ëª¨ë“  ì¹¸ì´ ì±„ì›Œì ¸ ìˆìŠµë‹ˆë‹¤)";
                return;
            }
        }

        if (bestCandidate) {
            highlightRecommendation(board.children[bestCandidate.index]);
            warning.textContent = recommendationMessage;
        } else {
            warning.textContent = "íƒ€ì¼ì„ ë°°ì¹˜í•  ìˆ˜ ìˆëŠ” ìµœì ì˜ ìœ„ì¹˜ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜)";
        }
    }

    function highlightRecommendation(element) {
        removeRecommendationHighlight();
        currentRecommendationElement = element;
        if (currentRecommendationElement) {
            currentRecommendationElement.classList.add('recommended');
        }
    }

    function removeRecommendationHighlight() {
        if (currentRecommendationElement) {
            currentRecommendationElement.classList.remove('recommended');
            currentRecommendationElement = null;
        }
    }

    function drawNextTile() {
      if (activeTile !== null) {
        warning.textContent = " ë½‘ì€ íƒ€ì¼ì„ ë¨¼ì € ë³´ë“œì— ë°°ì¹˜í•´ì•¼ í•©ë‹ˆë‹¤.";
        return;
      }
      if (placedCount >= 20) {
           warning.textContent = "ë³´ë“œê°€ ë‹¤ ì±„ì›Œì¡ŒìŠµë‹ˆë‹¤. ì ìˆ˜ ê³„ì‚°ì„ í™•ì¸í•˜ì„¸ìš”.";
           drawButton.disabled = true;
           return;
       }
      if (remainingTiles.length === 0 && placedCount < 20) {
           warning.textContent = "ì˜¤ë¥˜: ê²Œì„ ì§„í–‰ì— í•„ìš”í•œ íƒ€ì¼ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.";
           drawButton.disabled = true;
           return;
      }

      warning.textContent = "";
      removeRecommendationHighlight();

      const idxToDraw = Math.floor(Math.random() * remainingTiles.length);
      const drawnValue = remainingTiles[idxToDraw];

      // ê¸°ë¡: ë½‘ì€ ìˆœì„œ ì €ì¥
      if (Array.isArray(drawOrder)) { drawOrder.push(drawnValue); }

      const drawnTileElement = tileContainer.children[idxToDraw];
      if (!drawnTileElement) {
           console.error("Drawn tile element not found at index", idxToDraw, "Remaining:", remainingTiles);
           warning.textContent = "ì˜¤ë¥˜: ë½‘ì€ íƒ€ì¼ ìš”ì†Œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
          return;
      }

      drawnTileArea.appendChild(drawnTileElement);
      drawnTileElement.classList.add('highlight');

      remainingTiles.splice(idxToDraw, 1);

      activeTile = { value: drawnValue };

      renderRemainingTiles();

      drawButton.disabled = true;
      recommendBtn.disabled = false;
    }

    function handleCellClick(event) {
        const clickedCell = event.target;

        if (activeTile !== null && clickedCell.textContent === '') {
            clickedCell.textContent = activeTile.value === '*' ? 'â˜†' : activeTile.value;
            clickedCell.classList.add('placed');

            drawnTileArea.innerHTML = '';

            placedCount++;
            activeTile = null;
            warning.textContent = "";
            removeRecommendationHighlight();

            if (placedCount < 20) {
                drawButton.disabled = false;
                recommendBtn.disabled = true;
            } else {
                 drawButton.disabled = true;
                 recommendBtn.disabled = true;
                setTimeout(endGame, 100);
            }

        } else if (activeTile === null) {
            warning.textContent = "íƒ€ì¼ì„ ë¨¼ì € 'ë‹¤ìŒ íƒ€ì¼ ë½‘ê¸°' ë²„íŠ¼ìœ¼ë¡œ ë½‘ì•„ì£¼ì„¸ìš”.";
        } else if (clickedCell.textContent !== '') {
            warning.textContent = "ì´ë¯¸ íƒ€ì¼ì´ ë†“ì—¬ìˆëŠ” ì¹¸ì…ë‹ˆë‹¤.";
        }
    }

    function endGame() {
        warning.textContent = "ë³´ë“œê°€ ë‹¤ ì±„ì›Œì¡ŒìŠµë‹ˆë‹¤!";
        drawButton.disabled = true;
        recommendBtn.disabled = true;
        drawnTileArea.innerHTML = '';
        removeRecommendationHighlight();

        const jokerPlacedCell = Array.from(board.children).find(cell => cell.textContent === 'â˜†');

        if (jokerPlacedCell) {
            jokerArea.style.display = 'block';
            jokerSelect.innerHTML = '';
            for (let i = 1; i <= 30; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = i;
                jokerSelect.appendChild(option);
            }
             jokerSelect.value = 15;
             warning.textContent = "ì¡°ì»¤ ê°’ì„ ì„ íƒí•´ì£¼ì„¸ìš”.";
        } else {
            calculateScore();
        }
    }

    function confirmJoker() {
         const selectedValue = parseInt(jokerSelect.value, 10);
         const jokerPlacedCell = Array.from(board.children).find(cell => cell.textContent === 'â˜†');

         if (jokerPlacedCell && !isNaN(selectedValue)) {
             jokerPlacedCell.textContent = selectedValue;
         } else {
             warning.textContent = "ì¡°ì»¤ ê°’ì„ ì˜¬ë°”ë¥´ê²Œ ì„ íƒí•´ì£¼ì„¸ìš”.";
             return;
         }

         jokerArea.style.display = 'none';
         warning.textContent = "";

         calculateScore();
    }

    function calculateScore() {
        const boardValues = Array.from(board.children).map(cell => cell.textContent);
        let totalScore = getScoreFromBoard(boardValues);

        let breakdown = "ì ìˆ˜ ìƒì„¸: ";
        let currentSequenceValues = [];
        let currentSequenceLength = 0;
        let lastValue = -Infinity;
        let tempBreakdownParts = [];

        for (let i = 0; i < boardValues.length; i++) {
            const cellValue = parseInt(boardValues[i], 10);

            if (isNaN(cellValue)) {
                if (currentSequenceLength > 1) {
                    const sequenceScore = scoreTable[currentSequenceLength] || 0;
                    tempBreakdownParts.push(`[${currentSequenceValues.join('â†’')}] ${currentSequenceLength}ì¹¸(${sequenceScore}ì )`);
                }
                currentSequenceLength = 0;
                currentSequenceValues = [];
                lastValue = -Infinity;
                continue;
            }

            if (currentSequenceLength === 0 || cellValue >= lastValue) {
                currentSequenceLength++;
                currentSequenceValues.push(cellValue);
            } else {
                if (currentSequenceLength > 1) {
                    const sequenceScore = scoreTable[currentSequenceLength] || 0;
                    tempBreakdownParts.push(`[${currentSequenceValues.join('â†’')}] ${currentSequenceLength}ì¹¸(${sequenceScore}ì )`);
                }
                currentSequenceLength = 1;
                currentSequenceValues = [cellValue];
            }
            lastValue = cellValue;
        }

        if (currentSequenceLength > 1) {
            const sequenceScore = scoreTable[currentSequenceLength] || 0;
            tempBreakdownParts.push(`[${currentSequenceValues.join('â†’')}] ${currentSequenceLength}ì¹¸(${sequenceScore}ì )`);
        }

        breakdown += tempBreakdownParts.join(' + ');
        if (tempBreakdownParts.length === 0) {
            breakdown += "ì—°ì†ëœ ì˜¤ë¦„ì°¨ìˆœ/ê°™ìŒ êµ¬ê°„ì´ ì—†ìŠµë‹ˆë‹¤ (2ì¹¸ ì´ìƒ).";
        }

        document.getElementById('score').textContent = totalScore;
        scoreBreakdown.textContent = breakdown;
        submitBtn.disabled = false;
    }

    // --- ë¡œì»¬ ë­í‚¹(localStorage) ---
    const RANKING_KEY = 'streams_rankings';

    function saveRanking(playerName, score) {
        let rankings = getRankings();
        const now = new Date();
        const newEntry = {
            name: playerName,
            score: score,
            date: now.toLocaleString('ko-KR', {
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit'
            })
        };

        rankings.push(newEntry);

        rankings.sort((a, b) => {
            if (a.score === b.score) {
                return new Date(a.date).getTime() - new Date(b.date).getTime();
            }
            return b.score - a.score;
        });

        rankings = rankings.slice(0, 10);

        localStorage.setItem(RANKING_KEY, JSON.stringify(rankings));
        displayRanking();
    }

    function getRankings() {
        const storedRankings = localStorage.getItem(RANKING_KEY);
        return storedRankings ? JSON.parse(storedRankings) : [];
    }

    function displayRanking() {
        const rankings = getRankings();
        rankingList.innerHTML = '';

        if (rankings.length === 0) {
            rankingList.innerHTML = '<li>ì•„ì§ ë­í‚¹ì´ ì—†ìŠµë‹ˆë‹¤. ì²« ì ìˆ˜ë¥¼ ê¸°ë¡í•´ ë³´ì„¸ìš”!</li>';
            return;
        }

        rankings.forEach((entry, index) => {
            const listItem = document.createElement('li');
            listItem.innerHTML = `
                <span class="rank-name">${index + 1}. ${entry.name}</span>
                <span>
                    <span class="rank-score">${entry.score}ì </span>
                    <span class="rank-date">(${entry.date})</span>
                </span>
            `;
            rankingList.appendChild(listItem);
        });
    }

// êµì²´ ì‹œì‘: submitResult
async function submitResult() {
  const playerName = (document.getElementById('player')?.value || '').trim() || 'ìµëª…';
  const finalScore = parseInt(document.getElementById('score')?.textContent || '0', 10) || 0;

  // ë³´ë“œ ìƒíƒœ / ë½‘ì€ ìˆœì„œ
  const finalBoardState = Array.from(document.getElementById('board').children).map(cell => cell.textContent);
  const drawOrderState  = (typeof drawOrder !== 'undefined' && Array.isArray(drawOrder) ? drawOrder : [])
                            .map(v => v === '*' ? 'â˜†' : v);

  // í‘œì‹œìš© ë‚ ì§œ
  const nowStr = new Date().toLocaleString('ko-KR', {
    year:'numeric', month:'2-digit', day:'2-digit', hour:'2-digit', minute:'2-digit'
  });

  // ì•ˆë‚´
  alert(`${playerName}ë‹˜ì˜ ìµœì¢… ì ìˆ˜ëŠ” ${finalScore}ì ì…ë‹ˆë‹¤!\n(ê²°ê³¼ê°€ ì„œë²„ ë­í‚¹/ì›”ë³„ ë­í‚¹ì—ë„ ë°˜ì˜ë©ë‹ˆë‹¤.)`);

  // 1) ë¡œì»¬ ë­í‚¹ ê°±ì‹ (ì™¼ìª½ ì¹´ë“œ)
  saveRanking(playerName, finalScore);

  // 2) ì„œë²„(GAS)ë¡œ ê¸°ë¡ ì €ì¥ â†’ êµ¬ê¸€ì‹œíŠ¸ ë°˜ì˜
  try {
    if (typeof gasSave === 'function') {
      await gasSave({
        name:  playerName,
        score: finalScore,
        tiles: finalBoardState,
        order: drawOrderState,
        date:  nowStr
      
      });
      window.refreshLeaderboards && window.refreshLeaderboards();
    }
  } catch (e) {
    console.warn('GAS ì €ì¥ ì‹¤íŒ¨:', e);
  }

  // 3) ì„œë²„ ë­í‚¹/ì›”ë³„ ë­í‚¹ ë‹¤ì‹œ ë¶ˆëŸ¬ì˜¤ê¸°
  try {
    if (typeof refreshRanking === 'function') {
      await refreshRanking();
      await refreshMonthly();   // â† ì €ì¥ ì§í›„ ì›”ë³„ ì¬ì¡°íšŒ

    }
  } catch (e) {
    console.warn('ë­í‚¹ ìƒˆë¡œê³ ì¹¨ ì‹¤íŒ¨:', e);
  }

  // (ì„ íƒ) ê¸°ì¡´ ë¡œê·¸ ìœ ì§€
  console.log('--- ìŠ¤íŠ¸ë¦¼ìŠ¤ ê²Œì„ ê²°ê³¼ ---');
  console.log('í”Œë ˆì´ì–´:', playerName);
  console.log('ìµœì¢… ì ìˆ˜:', finalScore);
  console.log('ë½‘ì€ íƒ€ì¼ ìˆœì„œ:', drawOrderState.join(', '));
  console.log('ìµœì¢… ë³´ë“œ ìƒíƒœ:', finalBoardState.join(', '));
  console.log('------------------------');
 
 

}
// êµì²´ ë


    document.addEventListener('DOMContentLoaded', () => {
        renderRemainingTiles();
        renderBoard();
        drawButton.disabled = false;
        recommendBtn.disabled = true;
        submitBtn.disabled = true;
        displayRanking();
    });
  </script>
<script> 
    /* ---------- ë¡œì»¬ ë­í‚¹ (í´ë°±) ---------- */
    const RANKING_KEY='streams_rankings';
    function getRankings(){ const s=localStorage.getItem(RANKING_KEY); return s?JSON.parse(s):[]; }
    function saveRanking(name,score){
      let arr=getRankings();
      arr.push({name,score,date:new Date().toLocaleString('ko-KR',{year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit'})});
      arr.sort((a,b)=>(b.score===a.score)?(new Date(a.date)-new Date(b.date)):(b.score-a.score));
      arr=arr.slice(0,10); localStorage.setItem(RANKING_KEY, JSON.stringify(arr)); displayRanking();
    }
    function displayRanking(){
      const ul=rankingList; ul.innerHTML='';
      const arr=getRankings();
      if (!arr.length){ ul.innerHTML='<li>ì•„ì§ ë­í‚¹ì´ ì—†ìŠµë‹ˆë‹¤.</li>'; return; }
      arr.forEach((e,i)=>{
        const li=document.createElement('li');
        li.innerHTML=`<span class="rank-name">${i+1}. ${e.name}</span><span><span class="rank-score">${e.score}ì </span> <span class="rank-date">(${e.date})</span></span>`;
        ul.appendChild(li);
      });
    }

    /* ---------- GAS ì €ì¥ ì—”ë“œí¬ì¸íŠ¸ ---------- */
    // ìƒë‹¨ ì–´ë”˜ê°€ì— ìˆëŠ” ìƒìˆ˜
    const GAS_ENDPOINT = 'https://script.google.com/macros/s/AKfycby5ZtLBzXl8sD4daPTIlvR4mnq_DZM_z6HWQHrF48qnTwDI5URcvK_PpCg5mMq74RT8ww/exec';

    // ì´ í•¨ìˆ˜ë§Œ êµì²´
    async function gasSave({name, score, tiles, order, date}) {
      const params = new URLSearchParams({
        action: 'save',
        name : String(name || 'ìµëª…'),
        score: String(score || 0),
        tiles: Array.isArray(tiles) ? tiles.join(',') : String(tiles || ''),
        order: Array.isArray(order) ? order.join(',') : String(order || ''),
        date : String(date || '')
      });
      const res = await fetch(`${GAS_ENDPOINT}?${params.toString()}`, { method: 'GET' });

      // ì—¬ê¸°ì„œ ë°˜ë“œì‹œ ì‘ë‹µ ë‚´ìš©ì„ í™•ì¸!
      const txt = await res.text();
      let data;
      try { data = JSON.parse(txt); } catch { data = { ok:false, raw:txt }; }

      if (!res.ok || !data || data.ok === false) {
        console.warn('GAS save error:', res.status, data);
        throw new Error(`GAS save failed: HTTP ${res.status} / ${JSON.stringify(data)}`);
      }
      return data; // {ok:true, msg:'saved', ...}
    }


    /* ---------- GViz ì¡°íšŒ (ì „ì²´/ì›”ë³„) ---------- */
    const SHEET_ID   = '1jBL_ZHXPJUCCopdPm-SVjmQLDw_zoQHoO6K9vJ95CiI';
    const SHEET_NAME = 'ìŠ¤íŠ¸ë¦¼ìŠ¤';
    async function gasFetchTop(){
      const url=`https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(SHEET_NAME)}&range=A2:D`;
      const res=await fetch(url,{method:'GET'}); if(!res.ok) throw new Error('HTTP '+res.status);
      const txt=await res.text(); const match=txt.match(/\{[\s\S]*\}/); if(!match) throw new Error('Failed to parse GViz JSON');
      const data=JSON.parse(match[0]);
      const rows=(data.table?.rows||[]).map(r=>({
        index:r.c?.[0]?.v ?? '',
        date:(r.c?.[1]?.f ?? r.c?.[1]?.v ?? ''),
        name:r.c?.[2]?.v ?? 'ìµëª…',
        score:Number(r.c?.[3]?.v ?? 0)
      })).filter(r=>!Number.isNaN(r.score));
      rows.sort((a,b)=>(b.score===a.score)?String(a.date).localeCompare(String(b.date)):(b.score-a.score));
      return rows; // ì „ì²´ í–‰ ë°˜í™˜ (renderServerRankingì—ì„œ Top10ë§Œ ì”€)
    }

    function escapeHtml(s){ return String(s).replace(/[&<>\"']/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m])); }

    function renderServerRanking(rows){
      const ul=document.getElementById('rankingList'); if(!ul) return; ul.innerHTML='';
      if(!rows || !rows.length){ ul.innerHTML='<li>ì„œë²„ ë­í‚¹ì´ ì—†ìŠµë‹ˆë‹¤.</li>'; return; }
      rows.slice(0,10).forEach((r,i)=>{
        const li=document.createElement('li');
        const d=r.date||r.saved_at||'';
        li.innerHTML=`<span class="rank-name">${i+1}. ${escapeHtml(r.name||'ìµëª…')}</span><span><span class="rank-score">${escapeHtml(r.score)}</span> <span class="rank-date">(${escapeHtml(d)})</span></span>`;
        const s=li.querySelector('.rank-score'); if(s && !/ì $/.test(s.textContent)) s.textContent+= 'ì ';
        ul.appendChild(li);
      });
    }

    function monthKeyFrom(dateStr){ const s=String(dateStr||''); const m=s.match(/^(\d{4})[-/.](\d{1,2})/); if(!m) return ''; return `${m[1]}-${String(m[2]).padStart(2,'0')}`; }
    function buildMonthOptions(rows){
      const sel=document.getElementById('monthSelect'); if(!sel) return;
      const keys=Array.from(new Set(rows.map(r=>monthKeyFrom(r.date||r.saved_at)).filter(Boolean)));
      keys.sort((a,b)=>b.localeCompare(a));
      sel.innerHTML='';
      const now=new Date(); const currentKey=`${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}`;
      keys.forEach(k=>{ const o=document.createElement('option'); o.value=k; o.textContent=k; sel.appendChild(o); });
      if (keys.includes(currentKey)) sel.value=currentKey; else if(keys.length) sel.value=keys[0];
    }
    function renderMonthlyRankingFor(monthKey, rows){
      const ul=document.getElementById('rankingListMonthly'); if(!ul) return; ul.innerHTML='';
      const monthly=rows.filter(r=>monthKeyFrom(r.date||r.saved_at)===monthKey);
      if(!monthly.length){ ul.innerHTML='<li>ì´ ë‹¬ì˜ ë­í‚¹ì´ ì—†ìŠµë‹ˆë‹¤.</li>'; return; }
      monthly.slice(0,10).forEach((r,i)=>{
        const li=document.createElement('li'); const d=r.date||r.saved_at||'';
        li.innerHTML=`<span class="rank-name">${i+1}. ${escapeHtml(r.name||'ìµëª…')}</span><span><span class="rank-score">${escapeHtml(r.score)}</span> <span class="rank-date">(${escapeHtml(d)})</span></span>`;
        const s=li.querySelector('.rank-score'); if(s && !/ì $/.test(s.textContent)) s.textContent+='ì ';
        ul.appendChild(li);
      });
    }

    async function refreshRanking(){
      try{
        const data = await gasFetchTop();
        renderServerRanking(data); // ì „ì²´(ì—­ëŒ€)ë§Œ ê°±ì‹ 
      }catch(e){
        console.warn('Server ranking unavailable, falling back to local ranking.', e);
        if (typeof displayRanking==='function') displayRanking();
      }
    }


    // ì´ˆê¸° ë Œë”
    document.addEventListener('DOMContentLoaded', ()=>{
      renderRemainingTiles(); renderBoard(); drawButton.disabled=false; recommendBtn.disabled=true; submitBtn.disabled=true;
      displayRanking(); // ë¡œì»¬ í´ë°± ë¨¼ì €
      refreshRanking(); // ì„œë²„ ì‹œë„
    });
  </script>

<script>
/* ===== ì›”ë³„ ë­í‚¹ ì „ìš© ì½”ë“œ (ê¸°ì¡´ ì½”ë“œì™€ ë…ë¦½) ===== */

/* ë‚ ì§œ "YYYY-MM" í‚¤ ë½‘ê¸° */
function monthKeyFrom(dateStr){
  const s = String(dateStr || '');
  const m = s.match(/^(\d{4})[-/.](\d{1,2})/);
  if (!m) return '';
  return `${m[1]}-${String(m[2]).padStart(2,'0')}`;
}

/* GViz ì „ì²´ í–‰ ì½ê¸°: ê¸°ì¡´ gasFetchTopì€ ìƒìœ„ 10ê°œë§Œì´ë¯€ë¡œ, ì›”ë³„ìš©ìœ¼ë¡œ ì „ì²´ë¥¼ ìƒˆë¡œ ì½ìŠµë‹ˆë‹¤ */
async function gasFetchAllRows(){
  // ê¸°ì¡´ GAS ë¸”ë¡ì—ì„œ ì“°ëŠ” ìƒìˆ˜ ì¬ì‚¬ìš© (ì´ë¯¸ íŒŒì¼ í•˜ë‹¨ì— ì„ ì–¸ë˜ì–´ ìˆìŒ)
  // const SHEET_ID = '...'; const SHEET_NAME = '...';
  const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(SHEET_NAME)}&range=A2:D`;
  const res = await fetch(url);
  if(!res.ok) throw new Error('HTTP ' + res.status);
  const txt = await res.text();
  const match = txt.match(/\{[\s\S]*\}/);
  if(!match) throw new Error('Failed to parse GViz JSON');
  const data = JSON.parse(match[0]);

  // A=index, B=saved_at, C=name, D=score
  const rows = (data.table?.rows || []).map(r => ({
    index : r.c?.[0]?.v ?? '',
    date  : (r.c?.[1]?.f ?? r.c?.[1]?.v ?? ''),
    name  : r.c?.[2]?.v ?? 'ìµëª…',
    score : Number(r.c?.[3]?.v ?? 0)
  })).filter(r => !Number.isNaN(r.score));

  // ì ìˆ˜ ë‚´ë¦¼ì°¨ìˆœ, ë™ì ì‹œ ë‚ ì§œ ì˜¤ë¦„ì°¨ìˆœ
  rows.sort((a,b) => (b.score === a.score) ? String(a.date).localeCompare(String(b.date)) : b.score - a.score);
  return rows; // ì „ì²´ ë°˜í™˜
}

/* ë“œë¡­ë‹¤ìš´ ì˜µì…˜ ë§Œë“¤ê¸° (ì´ë²ˆ ë‹¬ ìš°ì„  ì„ íƒ) */
function buildMonthOptions(rows){
  const sel = document.getElementById('monthSelect');
  if (!sel) return;
  const keys = [...new Set(rows.map(r => monthKeyFrom(r.date)).filter(Boolean))].sort((a,b)=>b.localeCompare(a));
  sel.innerHTML = '';
  keys.forEach(k => {
    const opt = document.createElement('option');
    opt.value = k; opt.textContent = k; sel.appendChild(opt);
  });
  const now = new Date();
  const current = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}`;
  if (keys.includes(current)) sel.value = current;
  else if (keys.length) sel.value = keys[0];
}

/* ì„ íƒëœ ì›”ì˜ Top10 ë Œë” */
function renderMonthlyRankingFor(monthKey, rows){
  const ul = document.getElementById('rankingListMonthly');
  if (!ul) return;
  ul.innerHTML = '';
  const monthly = rows.filter(r => monthKeyFrom(r.date) === monthKey).slice(0,10);
  if (!monthly.length){
    ul.innerHTML = '<li>ì´ ë‹¬ì˜ ë­í‚¹ì´ ì—†ìŠµë‹ˆë‹¤.</li>';
    return;
  }
  monthly.forEach((r,i) => {
    const li = document.createElement('li');
    const d = r.date || '';
    li.innerHTML = `
      <span class="rank-name">${i+1}. ${r.name}</span>
      <span><span class="rank-score">${r.score}ì </span> <span class="rank-date">(${d})</span></span>`;
    ul.appendChild(li);
  });
}

/* í˜ì´ì§€ ë¡œë“œ ì‹œ ì›”ë³„ ë­í‚¹ ì´ˆê¸°í™” (ì „ì²´ ë­í‚¹ ë¡œì§ì€ ê¸°ì¡´ ì½”ë“œ ìœ ì§€) */
document.addEventListener('DOMContentLoaded', async () => {
  try{
    const rows = await gasFetchAllRows();  // ì „ì²´ ë°ì´í„°
    buildMonthOptions(rows);
    const sel = document.getElementById('monthSelect');
    if (sel && sel.options && sel.options.length){
      renderMonthlyRankingFor(sel.value, rows);
      sel.onchange = () => renderMonthlyRankingFor(sel.value, rows);
    }
  }catch(e){
    console.warn('ì›”ë³„ ë­í‚¹ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', e);
    const ul = document.getElementById('rankingListMonthly');
    if (ul) ul.innerHTML = '<li>ì›”ë³„ ë°ì´í„° ë¡œë”© ì‹¤íŒ¨</li>';
  }
});
</script>
<script>
async function refreshMonthly(){
  try{
    const rows = await gasFetchAllRows(); // ì „ì²´ í–‰
    buildMonthOptions(rows);
    const sel = document.getElementById('monthSelect');
    if (sel && sel.options && sel.options.length){
      renderMonthlyRankingFor(sel.value, rows);
      sel.onchange = () => renderMonthlyRankingFor(sel.value, rows);
    } else {
      const ul = document.getElementById('rankingListMonthly');
      if (ul) ul.innerHTML = '<li>ì›” ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</li>';
    }
  }catch(e){
    console.warn('ì›”ë³„ ë­í‚¹ ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨:', e);
    const ul = document.getElementById('rankingListMonthly');
    if (ul) ul.innerHTML = '<li>ì›”ë³„ ë°ì´í„° ë¡œë”© ì‹¤íŒ¨</li>';
  }
}
document.addEventListener('DOMContentLoaded', () => { refreshMonthly(); });
</script>
<script>
/* ===== ë‹¨ì¼ ë¦¬ë”ë³´ë“œ ëª¨ë“ˆ: ì „ì²´ Top10 + ì›”ë³„ Top10 (ì¶©ëŒ ë°©ì§€ìš©) ===== */
(function(){
  // ì‹œíŠ¸ ì •ë³´ (í•„ìš” ì‹œ ë°”ê¿”ì£¼ì„¸ìš”)
  const SHEET_ID   = '1jBL_ZHXPJUCCopdPm-SVjmQLDw_zoQHoO6K9vJ95CiI';
  const SHEET_NAME = 'ìŠ¤íŠ¸ë¦¼ìŠ¤';

  // DOM
  const overallUL = document.getElementById('rankingList');
  const monthUL   = document.getElementById('rankingListMonthly');
  const monthSel  = document.getElementById('monthSelect');

  if (!overallUL) return; // ì¹´ë“œê°€ ì—†ìœ¼ë©´ ì¢…ë£Œ

  // ìœ í‹¸
  const mkey = s => {
    const m = String(s||'').match(/^(\d{4})[-/.](\d{1,2})/);
    return m ? `${m[1]}-${String(m[2]).padStart(2,'0')}` : '';
  };
  const html = (i, r) =>
    `<span class="rank-name">${i}. ${r.name||'ìµëª…'}</span>
     <span><span class="rank-score">${r.score}ì </span> <span class="rank-date">(${r.date||''})</span></span>`;

  async function fetchAllRows(){
    const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?tqx=out:json&sheet=${encodeURIComponent(SHEET_NAME)}&range=A2:D`;
    const res = await fetch(url, {method:'GET'});
    if (!res.ok) throw new Error('HTTP '+res.status);
    const txt = await res.text();
    const m = txt.match(/\{[\s\S]*\}/);
    const data = JSON.parse(m[0]);
    const rows = (data.table?.rows||[]).map(r=>({
      index : r.c?.[0]?.v ?? '',
      date  : r.c?.[1]?.f ?? r.c?.[1]?.v ?? '',
      name  : r.c?.[2]?.v ?? 'ìµëª…',
      score : Number(r.c?.[3]?.v ?? 0),
    })).filter(r=>!Number.isNaN(r.score));
    // ì ìˆ˜ ë‚´ë¦¼ì°¨ìˆœ, ë™ì ì‹œ ë‚ ì§œ ì˜¤ë¦„
    rows.sort((a,b)=> (b.score===a.score) ? String(a.date).localeCompare(String(b.date)) : b.score-a.score);
    return rows;
  }

  function renderOverall(rows){
    if (!overallUL) return;
    overallUL.innerHTML = '';
    rows.slice(0,10).forEach((r, i)=>{
      const li = document.createElement('li');
      li.innerHTML = html(i+1, r);
      overallUL.appendChild(li);
    });
  }

  function buildMonthOptions(rows){
    if (!monthSel) return;
    const keys = [...new Set(rows.map(r=>mkey(r.date)).filter(Boolean))].sort((a,b)=>b.localeCompare(a));
    monthSel.innerHTML = '';
    keys.forEach(k=>{
      const o = document.createElement('option');
      o.value = k; o.textContent = k;
      monthSel.appendChild(o);
    });
    const now = new Date();
    const cur = `${now.getFullYear()}-${String(now.getMonth()+1).padStart(2,'0')}`;
    monthSel.value = keys.includes(cur) ? cur : (keys[0]||'');
  }

  function renderMonthly(rows){
    if (!monthUL || !monthSel) return;
    monthUL.innerHTML = '';
    const target = monthSel.value;
    const list = rows.filter(r=>mkey(r.date)===target).slice(0,10);
    if (!list.length){ monthUL.innerHTML='<li>ì´ ë‹¬ì˜ ë­í‚¹ì´ ì—†ìŠµë‹ˆë‹¤.</li>'; return; }
    list.forEach((r,i)=>{
      const li = document.createElement('li');
      li.innerHTML = html(i+1, r);
      monthUL.appendChild(li);
    });
  }

  async function refreshAll(){
    try{
      const rows = await fetchAllRows();   // í•­ìƒ "ì „ì²´ í–‰"
      renderOverall(rows);                 // ì „ì²´ Top10
      if (monthSel && monthUL){
        buildMonthOptions(rows);           // ë“œë¡­ë‹¤ìš´
        renderMonthly(rows);               // í˜„ì¬ ì„ íƒ ì›” Top10
        monthSel.onchange = ()=> renderMonthly(rows);
      }
    } catch (e){
      console.warn('ë¦¬ë”ë³´ë“œ ê°±ì‹  ì‹¤íŒ¨:', e);
      if (overallUL && !overallUL.children.length)
        overallUL.innerHTML = '<li>ì„œë²„ ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</li>';
      if (monthUL && !monthUL.children.length)
        monthUL.innerHTML = '<li>ì›”ë³„ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</li>';
    }
  }

  // ì™¸ë¶€ì—ì„œ ì €ì¥ í›„ ì¬í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ ë…¸ì¶œ
  window.refreshLeaderboards = refreshAll;

  // DOM ì¤€ë¹„ í›„ í•œ ë²ˆë§Œ ì‹¤í–‰ (ê¸°ì¡´ ì¤‘ë³µ ë¡œì§ì´ ìˆì–´ë„ ìš°ë¦¬ê°€ ë§ˆì§€ë§‰ì— ë®ì–´ì”€)
  document.addEventListener('DOMContentLoaded', ()=>{
    // ë‹¤ë¥¸ ìŠ¤í¬ë¦½íŠ¸ë³´ë‹¤ ëŠ¦ê²Œ ì‹¤í–‰ë˜ë„ë¡ ì•½ê°„ ì§€ì—°
    setTimeout(refreshAll, 50);
  });
})();
</script>

</body>
</html>






